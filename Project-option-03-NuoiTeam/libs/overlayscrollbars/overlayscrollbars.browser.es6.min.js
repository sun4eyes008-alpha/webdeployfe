/*!
 * OverlayScrollbars
 * Version: 2.4.5
 *
 * Copyright (c) Rene Haas | KingSora.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 */

var OverlayScrollbarsGlobal = function (t) { "use strict"; const e = (t, e) => { const { o: n, u: r, _: o } = t; let s, l = n; const i = (t, e) => { const n = l, i = t, c = e || (r ? !r(n, i) : n !== i); return (c || o) && (l = i, s = n), [l, c, s] }; return [e ? t => i(e(l, s), t) : i, t => [l, !!t, s]] }, n = "undefined" != typeof window, r = n && Node.ELEMENT_NODE, { toString: o, hasOwnProperty: s } = Object.prototype, l = /^\[object (.+)\]$/, i = t => void 0 === t, c = t => null === t, a = t => i(t) || c(t) ? `${t}` : o.call(t).replace(l, "$1").toLowerCase(), u = t => "number" == typeof t, d = t => "string" == typeof t, p = t => "boolean" == typeof t, f = t => "function" == typeof t, h = t => Array.isArray(t), y = t => "object" == typeof t && !h(t) && !c(t), v = t => { const e = !!t && t.length, n = u(e) && e > -1 && e % 1 == 0; return !(!(h(t) || !f(t) && n) || e > 0 && y(t) && !(e - 1 in t)) }, b = t => { if (!t || !y(t) || "object" !== a(t)) return !1; let e; const n = "constructor", r = t[n], o = r && r.prototype, l = s.call(t, n), c = o && s.call(o, "isPrototypeOf"); if (r && !l && !c) return !1; for (e in t); return i(e) || s.call(t, e) }, w = t => { const e = HTMLElement; return !!t && (e ? t instanceof e : t.nodeType === r) }, g = t => { const e = Element; return !!t && (e ? t instanceof e : t.nodeType === r) }; function m(t, e) { if (v(t)) for (let n = 0; n < t.length && !1 !== e(t[n], n, t); n++); else t && m(Object.keys(t), (n => e(t[n], n, t))); return t } const x = (t, e) => t.indexOf(e) >= 0, $ = (t, e) => t.concat(e), S = (t, e, n) => (n || d(e) || !v(e) ? t.push(e) : Array.prototype.push.apply(t, e), t), O = t => { const e = Array.from, n = []; return e && t ? e(t) : (t instanceof Set ? t.forEach((t => { S(n, t) })) : m(t, (t => { S(n, t) })), n) }, E = t => !!t && !t.length, C = t => O(new Set(t)), H = (t, e, n) => { m(t, (t => t && t.apply(void 0, e || []))), !n && (t.length = 0) }, D = (t, e) => Object.prototype.hasOwnProperty.call(t, e), P = t => t ? Object.keys(t) : [], M = (t, e, n, r, o, s, l) => { const i = [e, n, r, o, s, l]; return "object" == typeof t && !c(t) || f(t) || (t = {}), m(i, (e => { m(e, ((n, r) => { const o = e[r]; if (t === o) return !0; const s = h(o); if (o && b(o)) { const e = t[r]; let n = e; s && !h(e) ? n = [] : s || b(e) || (n = {}), t[r] = M(n, o) } else t[r] = s ? o.slice() : o })) })), t }, I = (t, e) => m(M({}, t), ((t, n, r) => { void 0 === t ? delete r[n] : e && t && b(t) && (r[n] = I(t, e)) })), T = t => { for (const e in t) return !1; return !0 }, k = (t, e, n) => { if (i(n)) return t ? t.getAttribute(e) : null; t && t.setAttribute(e, n) }, z = (t, e) => new Set((k(t, e) || "").split(" ")), A = (t, e) => { t && t.removeAttribute(e) }, L = (t, e, n, r) => { if (n) { const o = z(t, e); o[r ? "add" : "delete"](n); const s = O(o).join(" ").trim(); k(t, e, s) } }, _ = n && Element.prototype, N = (t, e) => { const n = [], r = e ? g(e) && e : document; return r ? S(n, r.querySelectorAll(t)) : n }, R = (t, e) => !!g(t) && (_.matches || _.msMatchesSelector).call(t, e), j = t => t ? O(t.childNodes) : [], F = t => t && t.parentElement, V = (t, e) => { if (g(t)) { const n = _.closest; if (n) return n.call(t, e); do { if (R(t, e)) return t; t = F(t) } while (t) } }, q = () => { }, X = t => { if (v(t)) m(O(t), (t => X(t))); else if (t) { const e = F(t); e && e.removeChild(t) } }, B = (t, e, n) => { if (n && t) { let r, o = e; return v(n) ? (r = document.createDocumentFragment(), m(n, (t => { t === o && (o = t.previousSibling), r.appendChild(t) }))) : r = n, e && (o ? o !== e && (o = o.nextSibling) : o = t.firstChild), t.insertBefore(r, o || null), () => X(n) } return q }, U = (t, e) => B(t, null, e), Y = (t, e) => B(F(t), t && t.nextSibling, e), Z = t => { const e = document.createElement("div"); return k(e, "class", t), e }, J = t => { const e = Z(); return e.innerHTML = t.trim(), m(j(e), (t => X(t))) }, W = n ? window : {}, K = Math.max, G = Math.min, Q = Math.round, tt = Math.abs, et = W.cancelAnimationFrame, nt = W.requestAnimationFrame, rt = W.setTimeout, ot = W.clearTimeout, st = t => t.charAt(0).toUpperCase() + t.slice(1), lt = ["-webkit-", "-moz-", "-o-", "-ms-"], it = ["WebKit", "Moz", "O", "MS", "webkit", "moz", "o", "ms"], ct = {}, at = {}, ut = t => { let e = at[t]; if (D(at, t)) return e; const n = st(t), r = Z().style; return m(lt, (o => { const s = o.replace(/-/g, ""), l = [t, o + t, s + n, st(s) + n]; return !(e = l.find((t => void 0 !== r[t]))) })), at[t] = e || "" }, dt = t => { let e = ct[t] || W[t]; return D(ct, t) || (m(it, (n => (e = e || W[n + st(t)], !e))), ct[t] = e), e }, pt = dt("MutationObserver"), ft = dt("IntersectionObserver"), ht = dt("ResizeObserver"), yt = dt("ScrollTimeline"), vt = (t, ...e) => t.bind(0, ...e), bt = t => { let e; const n = t ? rt : nt, r = t ? ot : et; return [o => { r(e), e = n(o, f(t) ? t() : t) }, () => r(e)] }, wt = (t, e) => { let n, r, o, s = q; const { v: l, p: i, g: c } = e || {}, a = function (e) { s(), ot(n), n = r = void 0, s = q, t.apply(this, e) }, d = t => c && r ? c(r, t) : t, p = () => { s !== q && a(d(o) || o) }, h = function () { const t = O(arguments), e = f(l) ? l() : l; if (u(e) && e >= 0) { const l = f(i) ? i() : i, c = u(l) && l >= 0, h = e > 0 ? rt : nt, y = e > 0 ? ot : et, v = d(t) || t, b = a.bind(0, v); s(); const w = h(b, e); s = () => y(w), c && !n && (n = rt(p, l)), r = o = v } else a(t) }; return h.m = p, h }, gt = /[^\x20\t\r\n\f]+/g, mt = (t, e, n) => { const r = t && t.classList; let o, s = 0, l = !1; if (r && e && d(e)) { const t = e.match(gt) || []; for (l = t.length > 0; o = t[s++];)l = !!n(r, o) && l } return l }, xt = (t, e) => { mt(t, e, ((t, e) => t.remove(e))) }, $t = (t, e) => (mt(t, e, ((t, e) => t.add(e))), vt(xt, t, e)), St = { opacity: 1, zIndex: 1 }, Ot = (t, e) => { const n = t || "", r = e ? parseFloat(n) : parseInt(n, 10); return r == r ? r : 0 }, Et = (t, e, n) => String((null != e ? e[n] || e.getPropertyValue(n) : t.style[n]) || ""), Ct = t => { const e = t || 0; return isFinite(e) ? e : 0 }; function Ht(t, e) { const n = d(e); if (h(e) || n) { let r = n ? "" : {}; if (t) { const o = W.getComputedStyle(t, null); r = n ? Et(t, o, e) : e.reduce(((e, n) => (e[n] = Et(t, o, n), e)), r) } return r } t && m(e, ((n, r) => ((t, e, n) => { try { const { style: r } = t; i(r[e]) ? r.setProperty(e, n) : r[e] = ((t, e) => !St[t] && u(e) ? `${e}px` : e)(e, n) } catch (r) { } })(t, r, e[r]))) } const Dt = t => "rtl" === Ht(t, "direction"), Pt = (t, e, n) => { const r = e ? `${e}-` : "", o = n ? `-${n}` : "", s = `${r}top${o}`, l = `${r}right${o}`, i = `${r}bottom${o}`, c = `${r}left${o}`, a = Ht(t, [s, l, i, c]); return { t: Ot(a[s], !0), r: Ot(a[l], !0), b: Ot(a[i], !0), l: Ot(a[c], !0) } }, Mt = (t, e) => `translate${y(t) ? `(${t.x},${t.y})` : `${e ? "X" : "Y"}(${t})`}`, It = t => `${(100 * Ct(t)).toFixed(3)}%`, Tt = t => `${Ct(t)}px`, kt = "paddingTop", zt = "paddingRight", At = "paddingLeft", Lt = "paddingBottom", _t = "marginLeft", Nt = "marginRight", Rt = "marginBottom", jt = "overflowX", Ft = "overflowY", Vt = "width", qt = "height", Xt = "hidden", Bt = { w: 0, h: 0 }, Ut = (t, e) => e ? { w: e[`${t}Width`], h: e[`${t}Height`] } : Bt, Yt = t => Ut("inner", t || W), Zt = vt(Ut, "offset"), Jt = vt(Ut, "client"), Wt = vt(Ut, "scroll"), Kt = t => { const e = parseFloat(Ht(t, Vt)) || 0, n = parseFloat(Ht(t, qt)) || 0; return { w: e - Q(e), h: n - Q(n) } }, Gt = t => t.getBoundingClientRect(), Qt = t => !(!t || !t[qt] && !t[Vt]), te = (t, e) => { const n = Qt(t); return !Qt(e) && n }, ee = () => performance.now(), ne = (t, e, n, r) => { if (t && e) { let o = !0; return m(n, (n => { (r ? r(t[n]) : t[n]) !== (r ? r(e[n]) : e[n]) && (o = !1) })), o } return !1 }, re = (t, e) => ne(t, e, ["w", "h"]), oe = (t, e) => ne(t, e, ["x", "y"]), se = (t, e) => ne(t, e, ["t", "r", "b", "l"]), le = (t, e, n) => ne(t, e, [Vt, qt], n && (t => Q(t))); let ie; const ce = "passive", ae = () => { if (i(ie)) { ie = !1; try { W.addEventListener(ce, q, Object.defineProperty({}, ce, { get() { ie = !0 } })) } catch (t) { } } return ie }, ue = t => t.split(" "), de = (t, e, n, r) => { m(ue(e), (e => { t.removeEventListener(e, n, r) })) }, pe = (t, e, n, r) => { var o; const s = ae(), l = null != (o = s && r && r.S) ? o : s, i = r && r.$ || !1, c = r && r.O || !1, a = s ? { passive: l, capture: i } : i; return vt(H, ue(e).map((e => { const r = c ? o => { de(t, e, r, i), n(o) } : n; return t.addEventListener(e, r, a), vt(de, t, e, r, i) }))) }, fe = t => t.stopPropagation(), he = t => t.preventDefault(), ye = { x: 0, y: 0 }, ve = t => { const e = t && Gt(t); return e ? { x: e.left + W.pageYOffset, y: e.top + W.pageXOffset } : ye }, be = (t, e, n) => n ? n.n ? -t : n.i ? e - t : t : t, we = (t, e) => { const { x: n, y: r } = u(e) ? { x: e, y: e } : e || {}; u(n) && (t.scrollLeft = n), u(r) && (t.scrollTop = r) }, ge = t => ({ x: t.scrollLeft, y: t.scrollTop }), me = (t, e) => { m(h(e) ? e : [e], t) }, xe = t => { const e = new Map, n = (t, n) => { if (t) { const r = e.get(t); me((t => { r && r[t ? "delete" : "clear"](t) }), n) } else e.forEach((t => { t.clear() })), e.clear() }, r = (t, o) => { if (d(t)) { const r = e.get(t) || new Set; return e.set(t, r), me((t => { f(t) && r.add(t) }), o), vt(n, t, o) } p(o) && o && n(); const s = P(t), l = []; return m(s, (e => { const n = t[e]; n && S(l, r(e, n)) })), vt(H, l) }; return r(t || {}), [r, n, (t, n) => { m(O(e.get(t)), (t => { n && !E(n) ? t.apply(0, n) : t() })) }] }, $e = t => JSON.stringify(t, ((t, e) => { if (f(e)) throw 0; return e })), Se = (t, e) => t ? `${e}`.split(".").reduce(((t, e) => t && D(t, e) ? t[e] : void 0), t) : void 0, Oe = { paddingAbsolute: !1, showNativeOverlaidScrollbars: !1, update: { elementEvents: [["img", "load"]], debounce: [0, 33], attributes: null, ignoreMutation: null }, overflow: { x: "scroll", y: "scroll" }, scrollbars: { theme: "os-theme-dark", visibility: "auto", autoHide: "never", autoHideDelay: 1300, autoHideSuspend: !1, dragScroll: !0, clickScroll: !1, pointers: ["mouse", "touch", "pen"] } }, Ee = (t, e) => { const n = {}; return m($(P(e), P(t)), (r => { const o = t[r], s = e[r]; if (y(o) && y(s)) M(n[r] = {}, Ee(o, s)), T(n[r]) && delete n[r]; else if (D(e, r) && s !== o) { let t = !0; if (h(o) || h(s)) try { $e(o) === $e(s) && (t = !1) } catch (_) { } t && (n[r] = s) } })), n }, Ce = (t, e, n) => r => [Se(t, r), n || void 0 !== Se(e, r)], He = `data-overlayscrollbars`, De = "os-environment", Pe = `${De}-flexbox-glue`, Me = `${Pe}-max`, Ie = `os-scrollbar-hidden`, Te = `${He}-initialize`, ke = He, ze = `${ke}-overflow-x`, Ae = `${ke}-overflow-y`, Le = "overflowVisible", _e = "scrollbarHidden", Ne = "scrollbarPressed", Re = "updating", je = `${He}-viewport`, Fe = "arrange", Ve = "scrollbarHidden", qe = Le, Xe = `${He}-padding`, Be = qe, Ue = `${He}-content`, Ye = "os-size-observer", Ze = `${Ye}-appear`, Je = `${Ye}-listener`, We = `${Je}-scroll`, Ke = `${Je}-item`, Ge = `${Ke}-final`, Qe = "os-trinsic-observer", tn = "os-no-css-vars", en = "os-theme-none", nn = "os-scrollbar", rn = `${nn}-rtl`, on = `${nn}-horizontal`, sn = `${nn}-vertical`, ln = `${nn}-track`, cn = `${nn}-handle`, an = `${nn}-visible`, un = `${nn}-cornerless`, dn = `${nn}-transitionless`, pn = `${nn}-interaction`, fn = `${nn}-unusable`, hn = `${nn}-auto-hide`, yn = `${hn}-hidden`, vn = `${nn}-wheel`, bn = `${ln}-interactive`, wn = `${cn}-interactive`, gn = {}, mn = {}, xn = (t, e, n) => P(t).map((r => { const { static: o, instance: s } = t[r], [l, i, c] = n || [], a = n ? s : o; if (a) { const t = n ? a(l, i, e) : a(e); return (c || mn)[r] = t } })), $n = t => mn[t], Sn = "__osOptionsValidationPlugin", On = "__osSizeObserverPlugin", En = (() => ({ [On]: { static: () => (t, e, n) => { const r = 3333333, o = "scroll", s = J(`<div class="${Ke}" dir="ltr"><div class="${Ke}"><div class="${Ge}"></div></div><div class="${Ke}"><div class="${Ge}" style="width: 200%; height: 200%"></div></div></div>`), l = s[0], i = l.lastChild, c = l.firstChild, a = null == c ? void 0 : c.firstChild; let u, d = Zt(l), p = d, f = !1; const h = () => { we(c, r), we(i, r) }, y = t => { u = 0, f && (d = p, e(!0 === t)) }, v = t => { p = Zt(l), f = !t || !re(p, d), t ? (fe(t), f && !u && (et(u), u = nt(y))) : y(!1 === t), h() }, b = [U(t, s), pe(c, o, v), pe(i, o, v)]; return $t(t, We), Ht(a, { [Vt]: r, [qt]: r }), nt(h), [n ? vt(v, !1) : h, b] } } }))(); let Cn = 0; const Hn = "__osScrollbarsHidingPlugin", Dn = (() => ({ [Hn]: { static: () => ({ C: t => { const { H: e, I: n, A: r } = t, o = !(r || e || !n.x && !n.y) && document.createElement("style"); return o && (k(o, "id", `${je}-${Fe}-${Cn}`), Cn++), o }, T: (t, e, n, r, o, s, l) => [(e, s, l, i) => { if (t) { const { D: t } = o, { k: c, M: a } = e, { x: u, y: d } = a, { x: p, y: f } = c, h = t[i ? zt : At], y = t.paddingTop, v = s.w + l.w, b = s.h + l.h, w = { w: f && d ? `${f + v - h}px` : "", h: p && u ? `${p + b - y}px` : "" }; if (r) { const { sheet: t } = r; if (t) { const { cssRules: e } = t; if (e) { e.length || t.insertRule(`#${k(r, "id")} + [${je}~='${Fe}']::before {}`, 0); const n = e[0].style; n[Vt] = w.w, n[qt] = w.h } } } else Ht(n, { "--os-vaw": w.w, "--os-vah": w.h }) } return t }, (r, i, c) => { if (t) { const a = c || s(r), { D: u } = o, { M: d } = a, { x: p, y: f } = d, h = {}, y = t => m(t, (t => { h[t] = u[t] })); p && y([Rt, kt, Lt]), f && y([_t, Nt, At, zt]); const v = Ht(n, P(h)); return L(n, je, Fe), e || (h[qt] = ""), Ht(n, h), [() => { l(a, i, t, v), Ht(n, v), L(n, je, Fe, !0) }, a] } return [q] }], R: () => { let t = { w: 0, h: 0 }, e = 0; const n = () => { const t = W.screen, e = t.deviceXDPI || 0, n = t.logicalXDPI || 1; return W.devicePixelRatio || e / n }; return (r, o) => { const s = Yt(), l = { w: s.w - t.w, h: s.h - t.h }; if (0 === l.w && 0 === l.h) return; const i = tt(l.w), c = tt(l.h), a = { w: tt(Q(s.w / (t.w / 100))), h: tt(Q(s.h / (t.h / 100))) }, u = n(), d = i > 2 && c > 2, p = !((t, e) => { const n = tt(t), r = tt(e); return !(n === r || n + 1 === r || n - 1 === r) })(a.w, a.h); let f, h; return d && p && u !== e && u > 0 && ([h, f] = o(), M(r.P, h)), t = s, e = u, f } } }) } }))(), Pn = "__osClickScrollPlugin", Mn = (() => ({ [Pn]: { static: () => (t, e, n, r, o) => { let s = 0, l = q; const i = c => { l = ((t, e, n, r, o) => { let s = 0; const l = ee(), i = K(0, 133), c = n => { const a = ee(), u = a - l >= i, d = n ? 1 : 1 - (K(0, l + i - a) / i || 0), p = (e - t) * (f(o) ? o(d, d * i, 0, 1, i) : d) + t, h = u || 1 === d; r && r(p, 0, h), s = h ? 0 : nt((() => c())) }; return c(), t => { et(s), t && c(t) } })(c, c + r * Math.sign(n), 0, ((n, c, a) => { t(n); const u = e(); if (a && !(o >= u && o <= u + r)) { if (s) i(n); else { const t = rt((() => { i(n) }), 222); l = () => { clearTimeout(t) } } s++ } })) }; return i(0), () => l() } } }))(); let In; const Tn = (t, e, n, r) => { U(t, e); const o = Jt(e), s = Zt(e), l = Kt(n); return r && X(e), { x: s.h - o.h + l.h, y: s.w - o.w + l.w } }, kn = (t, e) => { Ht(t, { [jt]: Xt, [Ft]: Xt, direction: "rtl" }), we(t, { x: 0 }); const n = ve(t), r = ve(e); we(t, { x: -999 }); const o = ve(e); return { i: n.x === r.x, n: r.x !== o.x } }, zn = (t, e) => { const n = $t(t, Pe), r = Gt(t), o = Gt(e), s = le(o, r, !0), l = $t(t, Me), i = Gt(t), c = Gt(e), a = le(c, i, !0); return n(), l(), s && a }, An = () => (In || (In = (() => { const { body: t } = document, n = J(`<div class="${De}"><div></div></div>`)[0], r = n.firstChild, [o, , s] = xe(), [l, i] = e({ o: Tn(t, n, r), u: oe }, vt(Tn, t, n, r, !0)), [c] = i(), a = (t => { let e = !1; const n = $t(t, Ie); try { e = "none" === Ht(t, ut("scrollbar-width")) || "none" === W.getComputedStyle(t, "::-webkit-scrollbar").getPropertyValue("display") } catch (r) { } return n(), e })(n), u = { x: 0 === c.x, y: 0 === c.y }, d = { elements: { host: null, padding: !a, viewport: t => a && t === t.ownerDocument.body && t, content: !1 }, scrollbars: { slot: !0 }, cancel: { nativeScrollbarsOverlaid: !1, body: null } }, p = M({}, Oe), f = vt(M, {}, p), h = vt(M, {}, d), y = { P: c, I: u, H: a, A: "-1" === Ht(n, "zIndex"), L: !!yt, V: kn(n, r), U: zn(n, r), B: vt(o, "r"), j: h, G: t => M(d, t) && h(), N: f, q: t => M(p, t) && f(), F: M({}, d), W: M({}, p) }; return A(n, "style"), X(n), W.addEventListener("resize", (() => { let t; if (!(a || u.x && u.y)) { const e = $n(Hn); t = !!(e ? e.R() : q)(y, l) } s("r", [t]) })), y })()), In), Ln = (t, e) => f(e) ? e.apply(0, t) : e, _n = (t, e, n, r) => { const o = i(r) ? n : r; return Ln(t, o) || e.apply(0, t) }, Nn = (t, e, n, r) => { const o = i(r) ? n : r, s = Ln(t, o); return !!s && (w(s) ? s : e.apply(0, t)) }, Rn = new WeakMap, jn = t => Rn.get(t), Fn = (t, e, n, r) => { let o = !1; const { X: s, Y: l, J: i, K: c, Z: a, tt: u } = r || {}, d = wt((() => o && n(!0)), { v: 33, p: 99 }), [p, f] = ((t, e, n) => { let r = !1; const o = !!n && new WeakMap, s = s => { if (o && n) { const l = n.map((e => { const [n, r] = e || []; return [r && n ? (s || N)(n, t) : [], r] })); m(l, (n => m(n[0], (s => { const l = n[1], i = o.get(s) || []; if (t.contains(s) && l) { const t = pe(s, l.trim(), (n => { r ? (t(), o.delete(s)) : e(n) })); o.set(s, S(i, t)) } else H(i), o.delete(s) })))) } }; return s(), [() => { r = !0 }, s] })(t, d, i), h = l || [], y = $(s || [], h), v = (o, s) => { if (!E(s)) { const l = a || q, i = u || q, d = [], p = []; let y = !1, v = !1; if (m(s, (n => { const { attributeName: o, target: s, type: a, oldValue: u, addedNodes: f, removedNodes: b } = n, w = "attributes" === a, g = "childList" === a, $ = t === s, O = w && o, E = O ? k(s, o || "") : null, C = O && u !== E, H = x(h, o) && C; if (e && (g || !$)) { const e = w && C, a = e && c && R(s, c), p = (a ? !l(s, o, u, E) : !w || e) && !i(n, !!a, t, r); m(f, (t => S(d, t))), m(b, (t => S(d, t))), v = v || p } !e && $ && C && !l(s, o, u, E) && (S(p, o), y = y || H) })), f((t => C(d).reduce(((e, n) => (S(e, N(t, n)), R(n, t) ? S(e, n) : e)), []))), e) return !o && v && n(!1), [!1]; if (!E(p) || y) { const t = [C(p), y]; return !o && n.apply(0, t), t } } }, b = new pt(vt(v, !1)); return [() => (b.observe(t, { attributes: !0, attributeOldValue: !0, attributeFilter: y, subtree: e, childList: e, characterData: e }), o = !0, () => { o && (p(), b.disconnect(), o = !1) }), () => { if (o) return d.m(), v(!0, b.takeRecords()) }] }, Vn = (t, n, r) => { const o = 3333333, { nt: s, ot: l } = r || {}, i = $n(On), { V: c } = An(), a = vt(Dt, t), [u] = e({ o: !1, _: !0 }); return () => { const r = [], d = J(`<div class="${Ye}"><div class="${Je}"></div></div>`)[0], p = d.firstChild, f = t => { const e = t instanceof ResizeObserverEntry, r = !e && h(t); let l = !1, i = !1, a = !0; if (e) { const [e, , n] = u(t.contentRect), r = Qt(e), o = te(e, n); i = !n || o, l = !i && !r, a = !l } else r ? [, a] = t : i = !0 === t; if (s && a) { const e = r ? t[0] : Dt(d); we(d, { x: be(o, o, e && c), y: o }) } l || n({ st: r ? t : void 0, et: !r, ot: i }) }; if (ht) { const t = new ht((t => f(t.pop()))); t.observe(p), S(r, (() => { t.disconnect() })) } else { if (!i) return q; { const [t, e] = i(p, f, l); S(r, $([$t(d, Ze), pe(d, "animationstart", t)], e)) } } if (s) { const [t] = e({ o: void 0 }, a); S(r, pe(d, "scroll", (e => { const n = t(), [r, o, s] = n; o && (xt(p, "ltr rtl"), $t(p, r ? "rtl" : "ltr"), f([!!r, o, s])), fe(e) }))) } return vt(H, S(r, U(t, d))) } }, qn = (t, n) => { let r; const o = Z(Qe), [s] = e({ o: !1 }), l = (t, e) => { if (t) { const r = s((t => 0 === t.h || t.isIntersecting || t.intersectionRatio > 0)(t)), [, o] = r; return o && !e && n(r) && [r] } }, i = (t, e) => l(e.pop(), t); return [() => { const e = []; if (ft) r = new ft(vt(i, !1), { root: t }), r.observe(o), S(e, (() => { r.disconnect() })); else { const t = () => { const t = Zt(o); l(t) }; S(e, Vn(o, t)()), t() } return vt(H, S(e, U(t, o))) }, () => r && i(!0, r.takeRecords())] }, Xn = (t, e, n) => K(t, G(e, n)), Bn = (t, e, n) => { const r = Q(e), [o, s] = ((t, e) => [e && e.i ? t : 0, be(t, t, e)])(r, n), l = (s - t) / s, i = t / o, c = t / s, a = n ? n.n ? l : n.i ? i : c : c; return Xn(0, 1, a) }, Un = (t, e, n) => { if (n) { const t = e ? Vt : qt, { Ot: r, Ct: o } = n, s = Gt(o)[t], l = Gt(r)[t]; return Xn(0, 1, s / l) } const r = e ? "x" : "y", { Ht: o, zt: s } = t, l = s[r], i = o[r]; return Xn(0, 1, l / (l + i)) }, Yn = (t, e, n, r) => { const o = Un(t, r, e); return 1 / o * (1 - o) * n }, Zn = (t, e, n, r) => { const { j: o, A: s } = An(), { scrollbars: l } = o(), { slot: i } = l, { It: c, lt: a, it: u, At: d, Et: f, Tt: y, _t: v } = e, { scrollbars: b } = d ? {} : t, { slot: w } = b || {}, g = new Map, O = t => yt && new yt({ source: f, axis: t }), C = O("x"), D = O("y"), P = Nn([c, a, u], (() => v && y ? c : a), i, w), I = t => v && !y && F(t) === u, T = t => { g.forEach(((e, n) => { (!t || x(h(t) ? t : [t], n)) && ((e || []).forEach((t => { t && t.cancel() })), g.delete(n)) })) }, k = (t, e, n) => { const r = n ? $t : xt; m(t, (t => { r(t.Dt, e) })) }, z = (t, e) => { m(t, (t => { const [n, r] = e(t); Ht(n, r) })) }, A = (t, e, n, r) => e && t.animate(n, { timeline: e, composite: r }), L = (t, e) => { z(t, (t => { const { Ct: r } = t; return [r, { [e ? Vt : qt]: It(Un(n, e)) }] })) }, _ = (t, e) => { C && D ? t.forEach((t => { const { Dt: r, Ct: o } = t, s = vt(Yn, n, t), l = e && Dt(r), i = s(l ? 1 : 0, e), c = s(l ? 0 : 1, e); T(o), g.set(o, [A(o, e ? C : D, M({ transform: [Mt(It(i), e), Mt(It(c), e)] }, l ? { clear: ["left"] } : {}))]) })) : z(t, (t => { const { Ct: r, Dt: o } = t, { V: s } = An(), l = e ? "x" : "y", { Ht: i } = n, c = Dt(o), a = Yn(n, t, Bn(ge(f)[l], i[l], e && c && s), e); return [r, { transform: Mt(It(a), e) }] })) }, N = t => { const { Dt: e } = t, n = I(e) && e, { x: r, y: o } = ge(f); return [n, { transform: n ? Mt({ x: Tt(r), y: Tt(o) }) : "" }] }, R = (t, e, n, r) => A(t, e, { transform: [Mt(Tt(0), r), Mt(Tt(K(0, n - .5)), r)] }, "add"), j = [], V = [], q = [], B = (t, e, n) => { const r = p(n), o = !r || !n; (!r || n) && k(V, t, e), o && k(q, t, e) }, Y = t => { const e = t ? on : sn, n = t ? V : q, o = E(n) ? dn : "", l = Z(`${nn} ${e} ${o}`), i = Z(ln), c = Z(cn), a = { Dt: l, Ot: i, Ct: c }; return s || $t(l, tn), S(n, a), S(j, [U(l, i), U(i, c), vt(X, l), T, r(a, B, _, t)]), a }, J = vt(Y, !0), W = vt(Y, !1); return J(), W(), [{ kt: () => { L(V, !0), L(q) }, Mt: () => { _(V, !0), _(q) }, Rt: () => { if (v) if (D && D) { const { Ht: t } = n; $(q, V).forEach((({ Dt: e }) => { T(e), I(e) && g.set(e, [R(e, C, t.x, !0), R(e, D, t.y)]) })) } else z(V, N), z(q, N) }, Pt: B, Lt: { L: C, Vt: V, Ut: J, Bt: vt(z, V) }, jt: { L: D, Vt: q, Ut: W, Bt: vt(z, q) } }, () => (U(P, V[0].Dt), U(P, q[0].Dt), rt((() => { B(dn) }), 300), vt(H, j))] }, Jn = (t, e, n) => { const { lt: r, Et: o, Gt: s } = e; return (e, l, i, c) => { const { Dt: a, Ot: u, Ct: d } = e, [p, f] = bt(333), [h, y] = bt(), v = vt(i, [e], c), b = !!o.scrollBy, w = `client${c ? "X" : "Y"}`, g = c ? Vt : qt, m = c ? "left" : "top", x = c ? "w" : "h", $ = c ? "x" : "y", O = t => t.propertyName.indexOf(g) > -1; let E = !0; return vt(H, [pe(a, "pointerenter", (() => { l(pn, !0) })), pe(a, "pointerleave pointercancel", (() => { l(pn, !1) })), pe(a, "wheel", (t => { const { deltaX: e, deltaY: n, deltaMode: s } = t; b && E && 0 === s && F(a) === r && o.scrollBy({ left: e, top: n, behavior: "smooth" }), E = !1, l(vn, !0), p((() => { E = !0, l(vn) })), he(t) }), { S: !1, $: !0 }), pe(d, "transitionstart", (t => { if (O(t)) { const t = () => { v(), h(t) }; t() } })), pe(d, "transitionend transitioncancel", (t => { O(t) && (y(), v()) })), pe(a, "mousedown", vt(pe, s, "click", fe, { O: !0, $: !0 }), { $: !0 }), (() => { const e = "pointerup pointerleave pointercancel lostpointercapture", l = (t, e) => r => { const { Ht: s } = n, l = Zt(u)[x] - Zt(d)[x], i = e * r / l * s[$]; we(o, { [$]: t + i }) }; return pe(u, "pointerdown", (n => { const i = V(n.target, `.${cn}`) === d, c = i ? d : u, a = t.scrollbars, { button: p, isPrimary: f, pointerType: h } = n, { pointers: y } = a, v = 0 === p && f && a[i ? "dragScroll" : "clickScroll"] && (y || []).includes(h); if (L(r, ke, Ne, !0), v) { const t = !i && n.shiftKey, a = vt(Gt, d), p = vt(Gt, u), f = (t, e) => (t || a())[m] - (e || p())[m], h = Q(Gt(o)[g]) / Zt(o)[x] || 1, y = l(ge(o)[$] || 0, 1 / h), v = n[w], b = a(), O = p(), E = b[g], C = f(b, O) + E / 2, D = v - O[m], P = i ? 0 : D - C, M = t => { H(I), c.releasePointerCapture(t.pointerId) }, I = [vt(L, r, ke, Ne), pe(s, e, M), pe(s, "selectstart", (t => he(t)), { S: !1 }), pe(u, e, M), pe(u, "pointermove", (e => { const n = e[w] - v; (i || t) && y(P + n) }))]; if (t) y(P); else if (!i) { const t = $n(Pn); t && S(I, t(y, f, P, E, D)) } c.setPointerCapture(n.pointerId) } })) })(), f, y]) } }, Wn = ({ ut: t }) => ({ qt: e, sn: n, xt: r }) => { const { U: o } = An(), { ht: s } = e || {}, { ct: l } = n; (t || !o) && (s || r) && Ht(t, { [qt]: l ? "" : "100%" }) }, Kn = ({ lt: t, Zt: n, it: r, _t: o }, s) => { const [l, i] = e({ u: se, o: Pt() }, vt(Pt, t, "padding", "")); return ({ St: t, qt: e, sn: c, xt: a }) => { let [u, d] = i(a); const { H: p, U: f } = An(), { et: h, bt: y, gt: v } = e || {}, { rt: b } = c, [w, g] = t("paddingAbsolute"); (h || d || a || !f && y) && ([u, d] = l(a)); const m = !o && (g || v || d); if (m) { const t = !w || !n && !p, e = u.r + u.l, o = u.t + u.b, l = { [Nt]: t && !b ? -e : 0, [Rt]: t ? -o : 0, [_t]: t && b ? -e : 0, top: t ? -u.t : 0, right: t ? b ? -u.r : "auto" : 0, left: t ? b ? "auto" : -u.l : 0, [Vt]: t ? `calc(100% + ${e}px)` : "" }, i = { [kt]: t ? u.t : 0, [zt]: t ? u.r : 0, [Lt]: t ? u.b : 0, [At]: t ? u.l : 0 }; Ht(n || r, l), Ht(r, i), M(s, { Zt: u, en: !t, D: n ? i : M({}, l, i) }) } return { cn: m } } }, Gn = ({ lt: t, Zt: n, it: r, Qt: o, _t: s, vt: l, Tt: i, tn: c }, a) => { const u = vt(K, 0), d = "visible", p = 42, f = { u: re, o: { w: 0, h: 0 } }, h = { u: oe, o: { x: Xt, y: Xt } }, y = (t, e) => { const n = W.devicePixelRatio % 1 != 0 ? 1 : 0, r = { w: u(t.w - e.w), h: u(t.h - e.h) }; return { w: r.w > n ? r.w : 0, h: r.h > n ? r.h : 0 } }, v = t => 0 === t.indexOf(d), { P: b, U: w, H: g, I: m } = An(), x = $n(Hn), $ = !s && !g && (m.x || m.y), S = i && s, [O, E] = e(f, vt(Kt, r)), [C, H] = e(f, vt(Wt, r)), [D, P] = e(f), [I, T] = e(f), [z] = e(h), A = (e, n) => { if (Ht(r, { [qt]: "" }), n) { const { en: n, Zt: o } = a, { rn: s, k: l } = e, i = Kt(t), c = Jt(t), u = "content-box" === Ht(r, "boxSizing"), d = n || u ? o.b + o.t : 0, p = !(m.x && u); Ht(r, { [qt]: c.h + i.h + (s.x && p ? l.x : 0) - d }) } }, _ = (t, e) => { const n = g || t ? 0 : p, o = (t, o, s) => { const l = Ht(r, t), i = "scroll" === (e ? e[t] : l); return [l, i, i && !g ? o ? n : s : 0, o && !!n] }, [s, l, i, c] = o(jt, m.x, b.x), [a, u, d, f] = o(Ft, m.y, b.y); return { Jt: { x: s, y: a }, rn: { x: l, y: u }, k: { x: i, y: d }, M: { x: c, y: f } } }, N = (t, e, n, r) => { const o = (t, e) => { const n = v(t), r = e && n && t.replace(`${d}-`, "") || ""; return [e && !n ? t : "", v(r) ? "hidden" : r] }, [s, l] = o(n.x, e.x), [i, c] = o(n.y, e.y); return r[jt] = l && i ? l : s, r[Ft] = c && s ? c : i, _(t, r) }, R = (t, e, n, r) => { const { k: o, M: s } = t, { x: l, y: i } = s, { x: c, y: u } = o, { D: d } = a, p = e ? _t : Nt, f = e ? At : zt, h = d[p], y = d[Rt], v = d[f], b = d[Lt]; r[Vt] = `calc(100% + ${u + -1 * h}px)`, r[p] = -u + h, r[Rt] = -c + y, n && (r[f] = v + (i ? u : 0), r[Lt] = b + (l ? c : 0)) }, [j, F] = x ? x.T($, w, r, o, a, _, R) : [() => $, () => [q]]; return ({ St: e, qt: o, sn: i, xt: d }, { cn: p }) => { const { et: f, wt: h, bt: b, ht: x, gt: $, yt: V } = o || {}, { ct: q, rt: X } = i, [B, U] = e("showNativeOverlaidScrollbars"), [Y, Z] = e("overflow"), J = B && m.x && m.y, W = !s && !w && (f || b || h || U || x), G = f || p || b || $ || V || U, Q = v(Y.x), tt = v(Y.y), et = Q || tt; let nt, rt = E(d), ot = H(d), st = P(d), lt = T(d); if (U && g && l(Ve, _e, !J), W && (nt = _(J), A(nt, q)), G) { et && l(qe, Le, !1); const [t, e] = F(J, X, nt), [n, o] = rt = O(d), [s, i] = ot = C(d), a = Jt(r); let p = s, f = a; t(), (i || o || U) && e && !J && j(e, s, n, X) && (f = Jt(r), p = Wt(r)); const h = Yt(c), v = { w: u(K(s.w, p.w) + n.w), h: u(K(s.h, p.h) + n.h) }, b = { w: u((S ? h.w : f.w + u(a.w - s.w)) + n.w), h: u((S ? h.h : f.h + u(a.h - s.h)) + n.h) }; lt = I(b), st = D(y(v, b), d) } const [it, ct] = lt, [at, ut] = st, [dt, pt] = ot, [ft, ht] = rt, yt = { x: at.w > 0, y: at.h > 0 }, vt = Q && tt && (yt.x || yt.y) || Q && yt.x && !yt.y || tt && yt.y && !yt.x; if (p || $ || V || ht || pt || ct || ut || Z || U || W || G) { const e = { [Nt]: 0, [Rt]: 0, [_t]: 0, [Vt]: "", [jt]: "", [Ft]: "" }, n = N(J, yt, Y, e), o = j(n, dt, ft, X); s || R(n, X, o, e), W && A(n, q), s ? (k(t, ze, e[jt]), k(t, Ae, e[Ft])) : Ht(r, e) } L(t, ke, Le, vt), L(n, Xe, Be, vt), s || L(r, je, qe, et); const [bt, wt] = z(_(J).Jt); return M(a, { Jt: bt, zt: { x: it.w, y: it.h }, Ht: { x: at.w, y: at.h }, Kt: yt }), { Yt: wt, Wt: ct, Xt: ut } } }, Qn = (t, n, r, o) => { const [s, l, i, c, a] = (t => { const [e, n, r] = (t => { const e = An(), { j: n, H: r } = e, o = $n(Hn), s = o && o.C, { elements: l } = n(), { host: i, padding: c, viewport: a, content: u } = l, d = w(t), p = d ? {} : t, { elements: f } = p, { host: h, padding: y, viewport: v, content: b } = f || {}, g = d ? t : p.target, m = R(g, "textarea"), $ = g.ownerDocument, O = $.documentElement, E = g === $.body, C = $.defaultView, D = vt(_n, [g]), M = vt(Nn, [g]), I = vt(Ln, [g]), T = vt(Z, ""), _ = vt(D, T, a), N = vt(M, T, u), V = _(v), J = V === g, W = J && E, K = !J && N(b), G = !J && w(V) && V === K, Q = G && !!I(u), tt = Q ? _() : V, et = Q ? K : N(), nt = W ? O : G ? tt : V, rt = m ? D(T, i, h) : g, ot = W ? nt : rt, st = G ? et : K, lt = $.activeElement, it = !J && C.top === C && lt === g, ct = { It: g, lt: ot, it: nt, Zt: !J && M(T, c, y), ut: st, Qt: !J && !r && s && s(e), Et: W ? O : nt, Nt: W ? $ : nt, tn: C, Gt: $, ft: m, Tt: E, At: d, _t: J, nn: G, dt: (t, e) => ((t, e, n) => z(t, e).has(n))(nt, J ? ke : je, J ? e : t), vt: (t, e, n) => L(nt, J ? ke : je, J ? e : t, n) }, at = P(ct).reduce(((t, e) => { const n = ct[e]; return S(t, !(!n || !w(n) || F(n)) && n) }), []), ut = t => t ? x(at, t) : null, { It: dt, lt: pt, Zt: ft, it: ht, ut: yt, Qt: bt } = ct, wt = [() => { A(pt, ke), A(pt, Te), A(dt, Te), E && (A(O, ke), A(O, Te)) }], gt = m && ut(pt); let mt = m ? dt : j([yt, ht, ft, pt, dt].find((t => !1 === ut(t)))); const xt = W ? dt : yt || ht, St = vt(H, wt); return [ct, () => { k(pt, ke, J ? "viewport" : "host"), k(ft, Xe, ""), k(yt, Ue, ""), J || k(ht, je, ""); const t = E && !J ? $t(F(g), Ie) : q, e = t => { U(F(t), j(t)), X(t) }; if (gt && (Y(dt, pt), S(wt, (() => { Y(pt, dt), X(pt) }))), U(xt, mt), U(pt, ft), U(ft || pt, !J && ht), U(ht, yt), S(wt, (() => { t(), A(ft, Xe), A(yt, Ue), A(ht, ze), A(ht, Ae), A(ht, je), ut(yt) && e(yt), ut(ht) && e(ht), ut(ft) && e(ft) })), r && !J && (L(ht, je, Ve, !0), S(wt, vt(A, ht, je))), bt && (((t, e) => { B(F(t), t, e) })(ht, bt), S(wt, vt(X, bt))), it) { const t = "tabindex", e = k(ht, t); k(ht, t, "-1"), ht.focus(); const n = () => e ? k(ht, t, e) : A(ht, t), r = pe($, "pointerdown keydown", (() => { n(), r() })); S(wt, [n, r]) } else lt && lt.focus && lt.focus(); return mt = 0, St }, St] })(t), o = { Zt: { t: 0, r: 0, b: 0, l: 0 }, en: !1, D: { [Nt]: 0, [Rt]: 0, [_t]: 0, [kt]: 0, [zt]: 0, [Lt]: 0, [At]: 0 }, zt: { x: 0, y: 0 }, Ht: { x: 0, y: 0 }, Jt: { x: Xt, y: Xt }, Kt: { x: !1, y: !1 } }, { It: s, it: l, vt: i, _t: c } = e, { H: a, I: u, U: d } = An(), p = !a && (u.x || u.y), f = [Wn(e), Kn(e, o), Gn(e, o)]; return [n, t => { const e = {}, n = (p || !d) && ge(l); return i("", Re, !0), m(f, (n => { M(e, n(t, e) || {}) })), i("", Re), we(l, n), !c && we(s, 0), e }, o, e, r] })(t), [p, y, v] = ((t, n) => { let r, o, s, l, i; const { H: c } = An(), a = `[${ke}]`, p = `[${je}]`, y = ["tabindex"], v = ["wrap", "cols", "rows"], b = ["id", "class", "style", "open"], w = { ct: !1, rt: Dt(t.lt) }, { lt: S, it: O, ut: E, ft: C, _t: H, dt: D, vt: I } = t, { U: T, B: z } = An(), [L] = e({ u: re, o: { w: 0, h: 0 } }, (() => { const t = D(qe, Le), e = D(Fe, ""), n = e && ge(O); I(qe, Le), I(Fe, ""), I("", Re, !0); const r = Wt(E), o = Wt(O), s = Kt(O); return I(qe, Le, t), I(Fe, "", e), I("", Re), we(O, n), { w: o.w + r.w + s.w, h: o.h + r.h + s.h } })), _ = C ? v : $(b, v), N = wt(n, { v: () => r, p: () => o, g(t, e) { const [n] = t, [r] = e; return [$(P(n), P(r)).reduce(((t, e) => (t[e] = n[e] || r[e], t)), {})] } }), R = t => { m(t || y, (t => { if (x(y, t)) { const e = k(S, t); d(e) ? k(O, t, e) : A(O, t) } })) }, j = (t, e) => { const [r, o] = t, s = { ht: o }; return M(w, { ct: r }), !e && n(s), s }, F = ({ et: t, st: e, ot: r }) => { const o = (!t || r || e) && c ? N : n, [s, l] = e || []; e && M(w, { rt: s }), o({ et: t || r, ot: r, gt: l }) }, q = (t, e) => { const [, r] = L(), o = { bt: r }; return r && !e && (t ? n : N)(o), o }, X = (t, e, n) => { const r = { wt: e }; return e && !n ? N(r) : H || R(t), r }, [B, U] = E || !T ? qn(S, j) : [], Y = !H && Vn(S, F, { ot: !0, nt: !0 }), [Z, J] = Fn(S, !1, X, { Y: b, X: $(b, y) }), W = H && ht && new ht((t => { const e = t[t.length - 1].contentRect; F({ et: !0, ot: te(e, i) }), i = e })); return [() => { R(), W && W.observe(S); const t = Y && Y(), e = B && B(), n = Z(), r = z((t => { const [, e] = L(); N({ yt: t, bt: e }) })); return () => { W && W.disconnect(), t && t(), e && e(), l && l(), n(), r() } }, ({ St: t, $t: e, xt: n }) => { const i = {}, [c] = t("update.ignoreMutation"), [d, y] = t("update.attributes"), [v, b] = t("update.elementEvents"), [w, m] = t("update.debounce"), x = e || n; if (b || y) { s && s(), l && l(); const [t, e] = Fn(E || O, !0, q, { X: $(_, d || []), J: v, K: a, tt: (t, e) => { const { target: n, attributeName: r } = t; return !(e || !r || H) && ((t, e, n) => { const r = V(t, e), o = t && ((t, e) => { const n = e ? g(e) && e : document; return n ? n.querySelector(t) : null })(n, r), s = V(o, e) === r; return !(!r || !o) && (r === t || o === t || s && V(V(t, n), e) !== r) })(n, a, p) || !!V(n, `.${nn}`) || !!(t => f(c) && c(t))(t) } }); l = t(), s = e } if (m) if (N.m(), h(w)) { const t = w[0], e = w[1]; r = u(t) && t, o = u(e) && e } else u(w) ? (r = w, o = !1) : (r = !1, o = !1); if (x) { const t = J(), e = U && U(), n = s && s(); t && M(i, X(t[0], t[1], x)), e && M(i, j(e[0], x)), n && M(i, q(n[0], x)) } return i }, w] })(c, (t => { D({}, t) })), [b, O, , E] = ((t, e, n, r, o, s) => { let l, i, c, a, u, d = q, p = 0; const [f, h] = bt(), [y, v] = bt(), [b, w] = bt(100), [g, m] = bt(100), [x, $] = bt(100), [O, E] = bt((() => p)), [C, D] = Zn(t, o, r, Jn(e, o, r)), { lt: P, Nt: M, Tt: I } = o, { Pt: T, kt: k, Mt: z, Rt: A } = C, L = t => { T(hn, t, !0), T(hn, t, !1) }, _ = (t, e) => { if (E(), t) T(yn); else { const t = vt(T, yn, !0); p > 0 && !e ? O(t) : t() } }, N = t => "mouse" === t.pointerType, R = t => { N(t) && (a = i, a && _(!0)) }, j = [w, E, m, $, v, h, () => d(), pe(P, "pointerover", R, { O: !0 }), pe(P, "pointerenter", R), pe(P, "pointerleave", (t => { N(t) && (a = !1, i && _(!1)) })), pe(P, "pointermove", (t => { N(t) && l && f((() => { w(), _(!0), g((() => { l && _(!1) })) })) })), pe(M, "scroll", (t => { y((() => { z(), c && _(!0), b((() => { c && !a && _(!1) })) })), s(t), A() }))]; return [() => vt(H, S(j, D())), ({ St: t, xt: e, qt: o, Ft: s }) => { const { Wt: a, Xt: f, Yt: h } = s || {}, { gt: y, ot: v } = o || {}, { rt: b } = n, { I: w } = An(), { Ht: g, Jt: m, Kt: $ } = r, [S, O] = t("showNativeOverlaidScrollbars"), [E, C] = t("scrollbars.theme"), [H, D] = t("scrollbars.visibility"), [P, N] = t("scrollbars.autoHide"), [R, j] = t("scrollbars.autoHideSuspend"), [F] = t("scrollbars.autoHideDelay"), [V, q] = t("scrollbars.dragScroll"), [X, B] = t("scrollbars.clickScroll"), U = v && !e, Y = $.x || $.y, Z = a || f || y || e, J = h || D, W = S && w.x && w.y, K = (t, e) => { const n = "visible" === H || "auto" === H && "scroll" === t; return T(an, n, e), n }; if (p = F, U && (R && Y ? (L(!1), d(), x((() => { d = pe(M, "scroll", vt(L, !0), { O: !0 }) }))) : L(!0)), O && T(en, W), C && (T(u), T(E, !0), u = E), j && !R && L(!0), N && (l = "move" === P, i = "leave" === P, c = "never" !== P, _(!c, !0)), q && T(wn, V), B && T(bn, X), J) { const t = K(m.x, !0), e = K(m.y, !1); T(un, !(t && e)) } Z && (k(), z(), A(), T(fn, !g.x, !0), T(fn, !g.y, !1), T(rn, b && !I)) }, {}, C] })(t, n, v, i, c, o), C = t => P(t).some((e => !!t[e])), D = (t, e) => { const { ln: o, xt: s, $t: i, an: c } = t, a = o || {}, u = !!s, d = { St: Ce(n, a, u), ln: a, xt: u }; if (c) return O(d), !1; const p = e || y(M({}, d, { $t: i })), f = l(M({}, d, { sn: v, qt: p })); O(M({}, d, { qt: p, Ft: f })); const h = C(p), b = C(f), w = h || b || !T(a) || u; return w && r(t, { qt: p, Ft: f }), w }; return [() => { const { It: t, it: e, Gt: n, Tt: r } = c, o = r ? n.documentElement : t, l = ge(o), i = [p(), s(), b()]; return we(e, l), vt(H, i) }, D, () => ({ un: v, fn: i }), { _n: c, dn: E }, a] }, tr = (t, e, n) => { const { N: r } = An(), o = w(t), s = o ? t : t.target, l = jn(s); if (e && !l) { let l = !1; const a = [], u = {}, d = t => { const e = I(t, !0), n = $n(Sn); return n ? n(e, !0) : e }, p = M({}, r(), d(e)), [f, h, y] = xe(), [v, b, w] = xe(n), g = (t, e) => { w(t, e), y(t, e) }, [m, x, $, O, E] = Qn(t, p, (({ ln: t, xt: e }, { qt: n, Ft: r }) => { const { et: o, gt: s, ht: l, bt: i, wt: c, ot: a } = n, { Wt: u, Xt: d, Yt: p } = r; g("updated", [D, { updateHints: { sizeChanged: !!o, directionChanged: !!s, heightIntrinsicChanged: !!l, overflowEdgeChanged: !!u, overflowAmountChanged: !!d, overflowStyleChanged: !!p, contentMutation: !!i, hostMutation: !!c, appear: !!a }, changedOptions: t || {}, force: !!e }]) }), (t => g("scroll", [D, t]))), C = t => { (t => { Rn.delete(t) })(s), H(a), l = !0, g("destroyed", [D, t]), h(), b() }, D = { options(t, e) { if (t) { const n = e ? r() : {}, o = Ee(p, M(n, d(t))); T(o) || (M(p, o), x({ ln: o })) } return M({}, p) }, on: v, off: (t, e) => { t && e && b(t, e) }, state() { const { un: t, fn: e } = $(), { rt: n } = t, { zt: r, Ht: o, Jt: s, Kt: i, Zt: c, en: a } = e; return M({}, { overflowEdge: r, overflowAmount: o, overflowStyle: s, hasOverflow: i, padding: c, paddingAbsolute: a, directionRTL: n, destroyed: l }) }, elements() { const { It: t, lt: e, Zt: n, it: r, ut: o, Et: s, Nt: l } = O._n, { Lt: i, jt: c } = O.dn, a = t => { const { Ct: e, Ot: n, Dt: r } = t; return { scrollbar: r, track: n, handle: e } }, u = t => { const { Vt: e, Ut: n } = t, r = a(e[0]); return M({}, r, { clone: () => { const t = a(n()); return x({ an: !0 }), t } }) }; return M({}, { target: t, host: e, padding: n || r, viewport: r, content: o || r, scrollOffsetElement: s, scrollEventElement: l, scrollbarHorizontal: u(i), scrollbarVertical: u(c) }) }, update: t => x({ xt: t, $t: !0 }), destroy: vt(C, !1), plugin: t => u[P(t)[0]] }; return S(a, [E]), ((t, e) => { Rn.set(t, e) })(s, D), xn(gn, tr, [D, f, u]), ((t, e) => { const { nativeScrollbarsOverlaid: n, body: r } = e || {}, { I: o, H: s, j: l } = An(), { nativeScrollbarsOverlaid: a, body: u } = l().cancel, d = null != n ? n : a, p = i(r) ? u : r, f = (o.x || o.y) && d, h = t && (c(p) ? !s : p); return !!f || !!h })(O._n.Tt, !o && t.cancel) ? (C(!0), D) : (S(a, m()), g("initialized", [D]), D.update(!0), D) } return l }; return tr.plugin = t => { const e = h(t), n = e ? t : [t], r = n.map((t => xn(t, tr)[0])); return (t => { m(t, (t => m(t, ((e, n) => { gn[n] = t[n] })))) })(n), e ? r : r[0] }, tr.valid = t => { const e = t && t.elements, n = f(e) && e(); return b(n) && !!jn(n.target) }, tr.env = () => { const { P: t, I: e, H: n, V: r, U: o, A: s, L: l, F: i, W: c, j: a, G: u, N: d, q: p } = An(); return M({}, { scrollbarsSize: t, scrollbarsOverlaid: e, scrollbarsHiding: n, rtlScrollBehavior: r, flexboxGlue: o, cssCustomProperties: s, scrollTimeline: l, staticDefaultInitialization: i, staticDefaultOptions: c, getDefaultInitialization: a, setDefaultInitialization: u, getDefaultOptions: d, setDefaultOptions: p }) }, t.ClickScrollPlugin = Mn, t.OverlayScrollbars = tr, t.ScrollbarsHidingPlugin = Dn, t.SizeObserverPlugin = En, Object.defineProperties(t, { vn: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } }), t }({});