<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flowchart Editor (Bootstrap)</title>

  <!-- Bootstrap 5.3.8 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.8/css/bootstrap.min.css" />

  <script>
    window.onerror = function (message, source, lineno, colno, error) {
      alert("L·ªói h·ªá th·ªëng: " + message + "\nT·∫°i d√≤ng: " + lineno);
    };
  </script>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background-color: #f8f9fa;
    }

    .html-content {
      white-space: pre-wrap;
      font-family: monospace;
      background: #f8f9fa;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #dee2e6;
      font-size: 0.875rem;
    }

    .code-input {
      font-family: monospace;
      font-size: 13px;
    }

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }

    .group-item.active {
      background-color: #eff6ff;
      border-left: 4px solid #0d6efd;
      color: #0d47a1;
      font-weight: 600;
    }

    .leaf-card {
      border: 1px solid #86efac;
      background: white;
      border-radius: 6px;
      padding: 12px;
      margin-top: 8px;
      margin-bottom: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      transition: box-shadow 0.2s;
    }

    .leaf-card:hover {
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .tree-branch {
      margin-top: 8px;
      margin-left: 24px;
      border-left: 2px solid #e5e7eb;
      padding-left: 8px;
    }

    .branch-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      background-color: #f9fafb;
      border-radius: 6px;
      margin-right: 8px;
      transition: background-color 0.2s;
    }

    .branch-header:hover {
      background-color: #f3f4f6;
    }

    .icon-btn {
      width: 28px;
      height: 28px;
      padding: 4px;
      border: none;
      background: transparent;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: background-color 0.2s;
      color: #6b7280;
    }

    .icon-btn:hover {
      background-color: #e5e7eb;
    }

    .icon-btn.danger:hover {
      background-color: #fee2e2;
      color: #dc2626;
    }

    .icon-btn.success:hover {
      background-color: #dcfce7;
      color: #16a34a;
    }

    .icon-btn.info:hover {
      background-color: #dbeafe;
      color: #2563eb;
    }

    .empty-state {
      text-align: center;
      padding: 80px 20px;
      color: #9ca3af;
      border: 2px dashed #d1d5db;
      border-radius: 8px;
    }

    .modal-xl-custom {
      max-width: 85vw;
      height: 85vh;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    const Icon = ({ path, size = 18, color = "currentColor" }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        {path}
      </svg>
    );

    const Icons = {
      ChevronRight: <polyline points="9 18 15 12 9 6" />,
      ChevronDown: <polyline points="6 9 12 15 18 9" />,
      Plus: <><line x1="12" y1="5" x2="12" y2="19" /><line x1="5" y1="12" x2="19" y2="12" /></>,
      Trash2: <><polyline points="3 6 5 6 21 6" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /></>,
      Edit2: <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z" />,
      Save: <><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" /><polyline points="17 21 17 13 7 13 7 21" /><polyline points="7 3 7 8 15 8" /></>,
      Download: <><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" y1="15" x2="12" y2="3" /></>,
      Upload: <><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" y1="3" x2="12" y2="15" /></>,
      X: <><line x1="18" y1="6" x2="6" y2="18" /><line x1="6" y1="6" x2="18" y2="18" /></>,
      FileText: <><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" /><polyline points="14 2 14 8 20 8" /></>,
      Folder: <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" />,
      ArrowUp: <><line x1="12" y1="19" x2="12" y2="5" /><polyline points="5 12 12 5 19 12" /></>,
      ArrowDown: <><line x1="12" y1="5" x2="12" y2="19" /><polyline points="19 12 12 19 5 12" /></>,
    };

    const BtnIcon = ({ name, size = 18 }) => <Icon path={Icons[name]} size={size} />;

    const replaceAllSafe = (str, find, replace) => {
      if (!str) return "";
      const regex = new RegExp(`\\b${find}\\b`, "g");
      return str.replace(regex, replace);
    };

    const safeEvalFlowchartData = (dataStr, allConstants) => {
      let processedStr = dataStr;
      Object.entries(allConstants).forEach(([key, value]) => {
        const safeValue = value
          .replace(/\\/g, "\\\\")
          .replace(/"/g, '\\"')
          .replace(/\n/g, "\\n")
          .replace(/\r/g, "");
        processedStr = replaceAllSafe(processedStr, key, `"${safeValue}"`);
      });
      try {
        return new Function(`return (${processedStr})`)();
      } catch (e) {
        alert("L·ªói c√∫ ph√°p file JS: " + e.message);
        return {};
      }
    };

    const HtmlDisplay = ({ content }) => {
      if (!content) return null;
      const isHtml = /<[a-z][\s\S]*>/i.test(content);
      return (
        <div className={isHtml ? "html-content" : "text-secondary"}>
          {isHtml ? (
            <div dangerouslySetInnerHTML={{ __html: content }} />
          ) : (
            content
          )}
        </div>
      );
    };

    const FlowchartEditor = () => {
      const [data, setData] = useState({});
      const [expandedNodes, setExpandedNodes] = useState(new Set());
      const [editingNode, setEditingNode] = useState(null);
      const [groupedConstants, setGroupedConstants] = useState({
        "Ch∆∞a ph√¢n lo·∫°i": {},
      });
      const [showConstModal, setShowConstModal] = useState(false);

      const handleFileUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const content = event.target.result;
            const groupRegex = /\/\/\s*---\s*GROUP:\s*(.+?)\s*---/g;
            const groupsFound = [];
            let gMatch;
            while ((gMatch = groupRegex.exec(content)) !== null)
              groupsFound.push({ index: gMatch.index, name: gMatch[1] });

            const constRegex = /const\s+(\w+)\s*=\s*"([\s\S]*?)";/g;
            const constsFound = [];
            let cMatch;
            while ((cMatch = constRegex.exec(content)) !== null)
              constsFound.push({
                index: cMatch.index,
                key: cMatch[1],
                value: cMatch[2].replace(/<br>/g, "\n"),
              });

            const newGroupedConstants = { "Ch∆∞a ph√¢n lo·∫°i": {} };
            groupsFound.forEach((g) => {
              if (!newGroupedConstants[g.name])
                newGroupedConstants[g.name] = {};
            });

            constsFound.forEach((c) => {
              let targetGroup = "Ch∆∞a ph√¢n lo·∫°i";
              let maxGroupIndex = -1;
              for (const g of groupsFound) {
                if (g.index < c.index && g.index > maxGroupIndex) {
                  maxGroupIndex = g.index;
                  targetGroup = g.name;
                }
              }
              if (!newGroupedConstants[targetGroup])
                newGroupedConstants[targetGroup] = {};
              newGroupedConstants[targetGroup][c.key] = c.value;
            });

            setGroupedConstants(newGroupedConstants);
            const flatConstants = {};
            Object.values(newGroupedConstants).forEach((group) =>
              Object.assign(flatConstants, group)
            );

            const dataMatch = content.match(
              /const flowchartData = (\{[\s\S]+?\});\s*$/
            );
            if (dataMatch) {
              const parsed = safeEvalFlowchartData(
                dataMatch[1],
                flatConstants
              );
              setData(parsed);
              setExpandedNodes(new Set());
            }
          } catch (err) {
            alert("L·ªói ƒë·ªçc file: " + err.message);
          }
        };
        reader.readAsText(file);
      };

      const handleDownload = () => {
        try {
          let content = "/**\n * GENERATED BY FLOWCHART EDITOR\n */\n\n";
          content += "// --- KHAI B√ÅO BI·∫æN D√ôNG CHUNG ---\n";
          const flatConstants = {};
          Object.entries(groupedConstants).forEach(([groupName, items]) => {
            if (Object.keys(items).length > 0) {
              content += `\n// --- GROUP: ${groupName} ---\n`;
              Object.entries(items).forEach(([key, value]) => {
                const safeVal = value.replace(/\n/g, "<br>");
                content += `const ${key} = "${safeVal}";\n`;
                flatConstants[key] = value;
              });
            }
          });

          const cleanData = JSON.parse(JSON.stringify(data));
          const removeType = (obj) => {
            if (typeof obj === "object" && obj !== null) {
              delete obj.type;
              Object.values(obj).forEach(removeType);
            }
          };
          removeType(cleanData);

          let jsonString = JSON.stringify(cleanData, null, 2);
          const sortedConsts = Object.entries(flatConstants).sort(
            (a, b) => b[1].length - a[1].length
          );
          sortedConsts.forEach(([key, value]) => {
            const escapeRegExp = (string) =>
              string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            const jsonVal = JSON.stringify(value).slice(1, -1);
            const regex = new RegExp(`"${escapeRegExp(jsonVal)}"`, "g");
            jsonString = jsonString.replace(regex, key);
          });

          content += `\nconst flowchartData = ${jsonString};\n`;
          const blob = new Blob([content], { type: "text/javascript" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "loan-flowchart-final.js";
          a.click();
          URL.revokeObjectURL(url);
        } catch (e) {
          alert("L·ªói save: " + e.message);
        }
      };

      const getNode = (root, path) => {
        let cur = root;
        for (const k of path) cur = cur[k];
        return cur;
      };

      const updateNode = (path, val) => {
        const newData = { ...data };
        let cur = newData;
        for (let i = 0; i < path.length - 1; i++) cur = cur[path[i]];
        if (val === undefined) delete cur[path[path.length - 1]];
        else cur[path[path.length - 1]] = val;
        setData(newData);
      };

      const addNode = (path, isLeaf) => {
        const name = prompt(
          isLeaf ? "Nh·∫≠p t√™n K·∫øt qu·∫£ (FDF/HTML):" : "Nh·∫≠p t√™n Nh√°nh con:"
        );
        if (!name) return;
        const parent = path.length ? getNode(data, path) : data;
        if (parent[name]) {
          alert("T√™n n√†y ƒë√£ t·ªìn t·∫°i!");
          return;
        }
        const newNode = isLeaf
          ? {
            displayName: name,
            pdf: "",
            note: "",
            xmttib: "",
            xmttecom: "",
            type: "leaf",
          }
          : {};
        const newData = JSON.parse(JSON.stringify(data));
        let cur = newData;
        path.forEach((p) => (cur = cur[p]));
        cur[name] = newNode;
        setData(newData);
        setExpandedNodes((prev) => new Set([...prev, path.join(".")]));
      };

      const renameNode = (path) => {
        const parentPath = path.slice(0, -1);
        const oldName = path[path.length - 1];
        const newName = prompt(`ƒê·ªïi t√™n "${oldName}" th√†nh:`, oldName);
        if (!newName || newName === oldName) return;

        const parentNode =
          parentPath.length === 0 ? data : getNode(data, parentPath);
        if (parentNode[newName]) {
          alert("T√™n n√†y ƒë√£ t·ªìn t·∫°i!");
          return;
        }

        const keys = Object.keys(parentNode);
        const newParentNode = {};
        keys.forEach((k) => {
          if (k === oldName) {
            newParentNode[newName] = parentNode[oldName];
          } else {
            newParentNode[k] = parentNode[k];
          }
        });

        if (parentPath.length === 0) {
          setData(newParentNode);
        } else {
          updateNode(parentPath, newParentNode);
        }

        const oldPathStr = path.join(".");
        const newPath = [...parentPath, newName];
        const newPathStr = newPath.join(".");
        if (expandedNodes.has(oldPathStr)) {
          const next = new Set(expandedNodes);
          next.delete(oldPathStr);
          next.add(newPathStr);
          setExpandedNodes(next);
        }
      };

      const moveNode = (path, direction) => {
        const parentPath = path.slice(0, -1);
        const nodeKey = path[path.length - 1];
        const parentNode =
          parentPath.length === 0 ? data : getNode(data, parentPath);
        const keys = Object.keys(parentNode);
        const index = keys.indexOf(nodeKey);

        if (index === -1) return;
        if (direction === "up" && index === 0) return;
        if (direction === "down" && index === keys.length - 1) return;

        const newKeys = [...keys];
        const swapIndex = direction === "up" ? index - 1 : index + 1;
        [newKeys[index], newKeys[swapIndex]] = [
          newKeys[swapIndex],
          newKeys[index],
        ];

        const newParentNode = {};
        newKeys.forEach((k) => {
          newParentNode[k] = parentNode[k];
        });

        if (parentPath.length === 0) {
          setData(newParentNode);
        } else {
          updateNode(parentPath, newParentNode);
        }
      };

      const isLeafNode = (node) => {
        if (!node || typeof node !== "object") return false;
        if (node.type === "leaf") return true;
        if (
          "pdf" in node ||
          "xmtt" in node ||
          "xmttib" in node ||
          "note" in node ||
          "displayName" in node
        )
          return true;
        return false;
      };

      const renderTree = (node, path = []) => {
        const isLeaf = isLeafNode(node);
        const pathStr = path.join(".");
        const isExpanded = expandedNodes.has(pathStr);
        const currentKey = path[path.length - 1];

        if (isLeaf) {
          return (
            <div key={pathStr} className="leaf-card">
              <div className="d-flex justify-content-between align-items-start">
                <div>
                  <div className="fw-bold text-success d-flex align-items-center gap-2">
                    <span className="badge bg-success fs-6">K·∫øt qu·∫£</span>
                    {currentKey}
                  </div>
                  <div className="mt-2 text-secondary">
                    {node.displayName && <div>üóÇÔ∏è {node.displayName}</div>}
                    {node.pdf && <div>üìÑ {node.pdf}</div>}
                  </div>
                  <HtmlDisplay content={node.note} />
                </div>
                <div className="d-flex gap-1">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      moveNode(path, "up");
                    }}
                    className="icon-btn"
                    title="L√™n"
                  >
                    <BtnIcon name="ArrowUp" size={14} />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      moveNode(path, "down");
                    }}
                    className="icon-btn"
                    title="Xu·ªëng"
                  >
                    <BtnIcon name="ArrowDown" size={14} />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      setEditingNode({ path, node });
                    }}
                    className="icon-btn info"
                    title="Ch·ªânh s·ª≠a"
                  >
                    <BtnIcon name="Edit2" size={14} />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      if (confirm("X√≥a k·∫øt qu·∫£ n√†y?"))
                        updateNode(path, undefined);
                    }}
                    className="icon-btn danger"
                    title="X√≥a"
                  >
                    <BtnIcon name="Trash2" size={14} />
                  </button>
                </div>
              </div>
            </div>
          );
        }

        const keys = Object.keys(node || {});
        return (
          <div key={pathStr} className={path.length ? "tree-branch" : ""}>
            <div className="branch-header">
              <button
                onClick={() => {
                  const next = new Set(expandedNodes);
                  if (next.has(pathStr)) next.delete(pathStr);
                  else next.add(pathStr);
                  setExpandedNodes(next);
                }}
                className="icon-btn"
                style={{ padding: 0 }}
              >
                {isExpanded ? (
                  <BtnIcon name="ChevronDown" />
                ) : (
                  <BtnIcon name="ChevronRight" />
                )}
              </button>
              <span className="fw-semibold text-dark flex-grow-1 text-truncate">
                {currentKey || "Root"}{" "}
                <span className="text-muted small fw-normal ms-2">
                  ({keys.length})
                </span>
              </span>

              <div className="d-flex gap-1">
                {path.length > 0 && (
                  <>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        moveNode(path, "up");
                      }}
                      className="icon-btn"
                      title="L√™n"
                    >
                      <BtnIcon name="ArrowUp" size={14} />
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        moveNode(path, "down");
                      }}
                      className="icon-btn me-2"
                      title="Xu·ªëng"
                    >
                      <BtnIcon name="ArrowDown" size={14} />
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        renameNode(path);
                      }}
                      className="icon-btn info me-2"
                      title="ƒê·ªïi t√™n nh√≥m"
                    >
                      <BtnIcon name="Edit2" size={14} />
                    </button>
                  </>
                )}
                <button
                  onClick={() => addNode(path, true)}
                  className="btn btn-sm btn-outline-success d-flex align-items-center gap-1"
                  title="Th√™m K·∫øt qu·∫£ (FDF/HTML)"
                >
                  <BtnIcon name="Plus" size={14} /> FDF/HTML
                </button>
                <button
                  onClick={() => addNode(path, false)}
                  className="btn btn-sm btn-outline-primary d-flex align-items-center gap-1"
                  title="Th√™m Nh√°nh con"
                >
                  <BtnIcon name="Plus" size={14} /> Nh√°nh con
                </button>

                {path.length > 0 && (
                  <button
                    onClick={() => {
                      if (confirm("X√≥a nh√°nh n√†y?"))
                        updateNode(path, undefined);
                    }}
                    className="icon-btn danger"
                    title="X√≥a Nh√°nh"
                  >
                    <BtnIcon name="Trash2" size={14} />
                  </button>
                )}
              </div>
            </div>
            {isExpanded && (
              <div>
                {keys.map((k) => renderTree(node[k], [...path, k]))}
                {keys.length === 0 && (
                  <div className="ms-5 text-muted fst-italic small py-2">
                    Nh√°nh tr·ªëng.
                  </div>
                )}
              </div>
            )}
          </div>
        );
      };

      const ConstantsManager = () => {
        const [activeGroup, setActiveGroup] = useState(
          Object.keys(groupedConstants)[0] || "Ch∆∞a ph√¢n lo·∫°i"
        );
        const [tempGroups, setTempGroups] = useState(groupedConstants);

        const updateMainState = (newGroups) => {
          setTempGroups(newGroups);
          setGroupedConstants(newGroups);
        };

        const addGroup = () => {
          const name = prompt("T√™n nh√≥m m·ªõi:");
          if (!name) return;
          if (tempGroups[name]) {
            alert("Nh√≥m ƒë√£ t·ªìn t·∫°i");
            return;
          }
          updateMainState({ ...tempGroups, [name]: {} });
          setActiveGroup(name);
        };

        const renameGroup = (targetGroup) => {
          const groupToRename = targetGroup || activeGroup;
          const newName = prompt(
            `ƒê·ªïi t√™n nh√≥m "${groupToRename}" th√†nh:`,
            groupToRename
          );
          if (!newName || newName === groupToRename) return;
          if (tempGroups[newName]) {
            alert("T√™n nh√≥m ƒë√£ t·ªìn t·∫°i!");
            return;
          }
          const newGroups = {};
          Object.keys(tempGroups).forEach((key) => {
            if (key === groupToRename)
              newGroups[newName] = tempGroups[groupToRename];
            else newGroups[key] = tempGroups[key];
          });
          updateMainState(newGroups);
          if (activeGroup === groupToRename) setActiveGroup(newName);
        };

        const deleteGroup = () => {
          if (Object.keys(tempGroups).length <= 1) return;
          if (!confirm(`X√≥a group ${activeGroup}?`)) return;
          const n = { ...tempGroups };
          delete n[activeGroup];
          updateMainState(n);
          setActiveGroup(Object.keys(n)[0]);
        };

        const addVar = (e) => {
          e.preventDefault();
          const k = e.target.key.value.trim();
          const v = e.target.val.value;
          let exists = false;
          Object.values(tempGroups).forEach((g) => {
            if (g[k]) exists = true;
          });
          if (k && v && !exists) {
            const n = { ...tempGroups };
            n[activeGroup][k] = v;
            updateMainState(n);
            e.target.reset();
          } else if (exists) alert("T√™n bi·∫øn b·ªã tr√πng!");
        };

        const deleteVar = (key) => {
          if (!confirm("X√≥a bi·∫øn n√†y?")) return;
          const n = { ...tempGroups };
          delete n[activeGroup][key];
          updateMainState(n);
        };

        const updateVar = (key, newVal) => {
          const n = { ...tempGroups };
          n[activeGroup][key] = newVal;
          updateMainState(n);
        };

        return (
          <div className="modal d-block" style={{ backgroundColor: "rgba(0,0,0,0.5)" }}>
            <div className="modal-dialog modal-xl modal-xl-custom">
              <div className="modal-content" style={{ height: "100%" }}>
                <div className="modal-header bg-light">
                  <h5 className="modal-title d-flex align-items-center gap-2">
                    <BtnIcon name="FileText" /> Qu·∫£n l√Ω Bi·∫øn
                  </h5>
                  <button
                    type="button"
                    className="btn-close"
                    onClick={() => setShowConstModal(false)}
                  ></button>
                </div>
                <div className="modal-body p-0 d-flex" style={{ flex: 1, overflow: "hidden" }}>
                  <div className="col-3 border-end bg-light p-3