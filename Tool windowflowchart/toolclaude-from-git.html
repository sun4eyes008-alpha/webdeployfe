<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flowchart Editor (Fixed Group Rename)</title>

  <script>
    window.onerror = function (message, source, lineno, colno, error) {
      alert("Lß╗ùi hß╗ç thß╗æng: " + message + "\nTß║íi d├▓ng: " + lineno);
    };
  </script>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, sans-serif;
    }

    .html-content {
      white-space: pre-wrap;
      font-family: monospace;
      background: #f8fafc;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #e2e8f0;
    }

    .code-input {
      font-family: monospace;
      font-size: 13px;
    }

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }

    .group-item.active {
      background-color: #eff6ff;
      border-left: 4px solid #2563eb;
      color: #1e40af;
      font-weight: 600;
    }

    .animate-fade-in {
      animation: fadeIn 0.2s ease-in;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    // --- ICONS ---
    const Icon = ({ path, size = 18, color = "currentColor" }) => (
      <svg
        width={size}
        height={size}
        viewBox="0 0 24 24"
        fill="none"
        stroke={color}
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
      >
        {path}
      </svg>
    );
    const Icons = {
      ChevronRight: <polyline points="9 18 15 12 9 6" />,
      ChevronDown: <polyline points="6 9 12 15 18 9" />,
      Plus: (
        <>
          <line x1="12" y1="5" x2="12" y2="19" />
          <line x1="5" y1="12" x2="19" y2="12" />
        </>
      ),
      Trash2: (
        <>
          <polyline points="3 6 5 6 21 6" />
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
        </>
      ),
      Edit2: (
        <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z" />
      ),
      Save: (
        <>
          <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
          <polyline points="17 21 17 13 7 13 7 21" />
          <polyline points="7 3 7 8 15 8" />
        </>
      ),
      Download: (
        <>
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="7 10 12 15 17 10" />
          <line x1="12" y1="15" x2="12" y2="3" />
        </>
      ),
      Upload: (
        <>
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="17 8 12 3 7 8" />
          <line x1="12" y1="3" x2="12" y2="15" />
        </>
      ),
      X: (
        <>
          <line x1="18" y1="6" x2="6" y2="18" />
          <line x1="6" y1="6" x2="18" y2="18" />
        </>
      ),
      FileText: (
        <>
          <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" />
          <polyline points="14 2 14 8 20 8" />
        </>
      ),
      Folder: (
        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" />
      ),
      ArrowUp: (
        <>
          <line x1="12" y1="19" x2="12" y2="5" />
          <polyline points="5 12 12 5 19 12" />
        </>
      ),
      ArrowDown: (
        <>
          <line x1="12" y1="5" x2="12" y2="19" />
          <polyline points="19 12 12 19 5 12" />
        </>
      ),
    };
    const BtnIcon = ({ name, size }) => (
      <Icon path={Icons[name]} size={size} />
    );

    // --- HELPER FUNCTIONS ---
    const replaceAllSafe = (str, find, replace) => {
      if (!str) return "";
      const regex = new RegExp(`\\b${find}\\b`, "g");
      return str.replace(regex, replace);
    };

    const safeEvalFlowchartData = (dataStr, allConstants) => {
      let processedStr = dataStr;
      Object.entries(allConstants).forEach(([key, value]) => {
        // Only escape what's necessary for JSON
        const safeValue = value
          .replace(/\\/g, "\\\\")   // Escape backslashes
          .replace(/"/g, '\\"')      // Escape quotes
          .replace(/\n/g, "\\n")     // Convert newlines to \n
          .replace(/\r/g, "\\r")     // Convert carriage returns to \r
          .replace(/\t/g, "\\t");    // Convert tabs to \t
        processedStr = replaceAllSafe(processedStr, key, `"${safeValue}"`);
      });
      try {
        return new Function(`return (${processedStr})`)();
      } catch (e) {
        alert("Lß╗ùi c├║ ph├íp file JS: " + e.message);
        return {};
      }
    };

    const HtmlDisplay = ({ content }) => {
      if (!content) return null;
      const isHtml = /<[a-z][\s\S]*>/i.test(content);
      return (
        <div className={`small mt-1 ${isHtml ? "html-content" : "text-secondary"}`}>
          {isHtml ? (
            <div dangerouslySetInnerHTML={{ __html: content }} />
          ) : (
            content
          )}
        </div>
      );
    };

    // --- MAIN COMPONENT ---
    const FlowchartEditor = () => {
      const [data, setData] = useState({});
      const [expandedNodes, setExpandedNodes] = useState(new Set());
      const [editingNode, setEditingNode] = useState(null);
      const [groupedConstants, setGroupedConstants] = useState({
        "Ch╞░a ph├ón loß║íi": {},
      });
      const [showConstModal, setShowConstModal] = useState(false);

      // --- FILE PARSING ---
      const handleFileUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const content = event.target.result;

            const groupRegex = /\/\/\s*---\s*GROUP:\s*(.+?)\s*---/g;
            const groupsFound = [];
            let gMatch;
            while ((gMatch = groupRegex.exec(content)) !== null)
              groupsFound.push({ index: gMatch.index, name: gMatch[1] });

            // Parse constants - handle both "string" and `template literal`
            const constRegex = /const\s+(\w+)\s*=\s*(?:"([\s\S]*?)"|`([\s\S]*?)`);/g;
            const constsFound = [];
            let cMatch;

            // Helper function to decode HTML entities
            const decodeHtmlEntities = (text) => {
              const textarea = document.createElement('textarea');
              textarea.innerHTML = text;
              return textarea.value;
            };

            // Helper function to unescape string literals
            const unescapeString = (text) => {
              return text
                .replace(/\\n/g, "\n")      // Convert \n to actual newline
                .replace(/\\r/g, "\r")      // Convert \r to actual carriage return
                .replace(/\\t/g, "\t")      // Convert \t to actual tab
                .replace(/\\"/g, '"')       // Convert \" to "
                .replace(/\\'/g, "'")       // Convert \' to '
                .replace(/\\\\/g, "\\")     // Convert \\ to \
                .replace(/\\`/g, "`")       // Convert \` to `
                .replace(/\\\$/g, "$");     // Convert \$ to $
            };

            while ((cMatch = constRegex.exec(content)) !== null) {
              // cMatch[2] is double-quoted string, cMatch[3] is template literal
              let value = (cMatch[2] !== undefined ? cMatch[2] : cMatch[3] || "");

              // Unescape string literals first
              value = unescapeString(value);

              // Decode HTML entities (e.g., &lt; -> <, &gt; -> >)
              value = decodeHtmlEntities(value);

              // Replace <br> tags with newlines
              value = value
                .replace(/<br>/gi, "\n")
                .replace(/<\/br>/gi, "\n");

              constsFound.push({
                index: cMatch.index,
                key: cMatch[1],
                value: value,
              });
            }

            const newGroupedConstants = { "Ch╞░a ph├ón loß║íi": {} };
            groupsFound.forEach((g) => {
              if (!newGroupedConstants[g.name])
                newGroupedConstants[g.name] = {};
            });

            constsFound.forEach((c) => {
              let targetGroup = "Ch╞░a ph├ón loß║íi";
              let maxGroupIndex = -1;
              for (const g of groupsFound) {
                if (g.index < c.index && g.index > maxGroupIndex) {
                  maxGroupIndex = g.index;
                  targetGroup = g.name;
                }
              }
              if (!newGroupedConstants[targetGroup])
                newGroupedConstants[targetGroup] = {};
              newGroupedConstants[targetGroup][c.key] = c.value;
            });

            setGroupedConstants(newGroupedConstants);
            const flatConstants = {};
            Object.values(newGroupedConstants).forEach((group) =>
              Object.assign(flatConstants, group)
            );

            const dataMatch = content.match(
              /const flowchartData = (\{[\s\S]+?\});\s*$/
            );
            if (dataMatch) {
              const parsed = safeEvalFlowchartData(
                dataMatch[1],
                flatConstants
              );
              setData(parsed);
              setExpandedNodes(new Set());
            }
          } catch (err) {
            alert("Lß╗ùi ─æß╗ìc file: " + err.message);
          }
        };
        reader.readAsText(file);
      };

      const handleDownload = () => {
        try {
          let content = "/**\n * GENERATED BY FLOWCHART EDITOR\n */\n\n";
          content += "// --- KHAI B├üO BIß║╛N D├ÖNG CHUNG ---\n";
          const flatConstants = {};
          Object.entries(groupedConstants).forEach(([groupName, items]) => {
            if (Object.keys(items).length > 0) {
              content += `\n// --- GROUP: ${groupName} ---\n`;
              Object.entries(items).forEach(([key, value]) => {
                // Auto-detect HTML: nß║┐u c├│ HTML tags hoß║╖c <br> th├¼ d├╣ng backticks
                const hasHtml = /<[a-z][\s\S]*>/i.test(value) || value.includes('<br>');

                if (hasHtml) {
                  // D├╣ng template literal (backticks) cho HTML
                  const templateVal = value
                    .replace(/\\/g, '\\\\')
                    .replace(/`/g, '\\`')
                    .replace(/\$/g, '\\$');
                  content += `const ${key} = \`${templateVal}\`;\n`;
                } else {
                  // D├╣ng double quotes cho text th├┤ng th╞░ß╗¥ng
                  const safeVal = value
                    .replace(/\\/g, '\\\\')
                    .replace(/"/g, '\\"')
                    .replace(/\n/g, '<br>');
                  content += `const ${key} = "${safeVal}";\n`;
                }
                flatConstants[key] = value;
              });
            }
          });

          const cleanData = JSON.parse(JSON.stringify(data));
          const removeType = (obj) => {
            if (typeof obj === "object" && obj !== null) {
              delete obj.type;
              Object.values(obj).forEach(removeType);
            }
          };
          removeType(cleanData);

          let jsonString = JSON.stringify(cleanData, null, 2);
          const sortedConsts = Object.entries(flatConstants).sort(
            (a, b) => b[1].length - a[1].length
          );

          // Thay thß║┐ gi├í trß╗ï cß╗ºa biß║┐n (value) bß║▒ng t├¬n biß║┐n
          sortedConsts.forEach(([key, value]) => {
            const escapeRegExp = (string) =>
              string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            const jsonVal = JSON.stringify(value).slice(1, -1);
            const regex = new RegExp(`"${escapeRegExp(jsonVal)}"`, "g");
            jsonString = jsonString.replace(regex, key);
          });

          // Thay thß║┐ t├¬n biß║┐n khi ng╞░ß╗¥i d├╣ng nhß║¡p trß╗▒c tiß║┐p (v├¡ dß╗Ñ: "ecslide11" -> ecslide11)
          Object.keys(flatConstants).forEach((varName) => {
            // T├¼m c├íc tr╞░ß╗¥ng hß╗úp "varName" v├á thay bß║▒ng varName (kh├┤ng c├│ dß║Ñu ngoß║╖c k├⌐p)
            const regex = new RegExp(`"(${varName})"`, "g");
            jsonString = jsonString.replace(regex, (match, p1) => {
              // Chß╗ë thay thß║┐ nß║┐u ─æ├║ng l├á t├¬n biß║┐n (kh├┤ng phß║úi l├á mß╗Öt phß║ºn cß╗ºa string kh├íc)
              return p1;
            });
          });

          // Thay thß║┐ c├íc field c├│ HTML bß║▒ng template literals (backticks)
          // Sß╗¡ dß╗Ñng mß╗Öt approach kh├íc: Parse tß╗½ng d├▓ng thay v├¼ d├╣ng regex phß╗⌐c tß║íp
          const lines = jsonString.split('\n');
          const processedLines = lines.map(line => {
            // Match pattern: "fieldname": "value..."
            const fieldMatch = line.match(/^(\s*)(".*?"):\s*"(.*)"(,?)$/);
            if (fieldMatch) {
              const indent = fieldMatch[1];
              const fieldName = fieldMatch[2];
              const value = fieldMatch[3];
              const comma = fieldMatch[4];

              // Check if value contains HTML tags
              const hasHtml = /<[a-z][\s\S]*>/i.test(value);

              if (hasHtml) {
                // Convert to template literal
                // Value ─æ├ú ─æ╞░ß╗úc JSON.stringify n├¬n cß║ºn unescape quotes
                const unescapedValue = value
                  .replace(/\\"/g, '"')      // Unescape quotes
                  .replace(/\\n/g, '\n')     // Convert \n to newlines
                  .replace(/\\r/g, '\r')     // Convert \r to carriage returns
                  .replace(/\\t/g, '\t');    // Convert \t to tabs

                // Now escape for template literals
                const backtickValue = unescapedValue
                  .replace(/\\/g, '\\\\')    // Escape backslashes
                  .replace(/`/g, '\\`')      // Escape backticks
                  .replace(/\$/g, '\\$');    // Escape dollar signs

                return `${indent}${fieldName}: \`${backtickValue}\`${comma}`;
              }
            }
            return line;
          });
          jsonString = processedLines.join('\n');

          content += `\nconst flowchartData = ${jsonString};\n`;
          const blob = new Blob([content], { type: "text/javascript" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "loan-flowchart-final.js";
          a.click();
          URL.revokeObjectURL(url);
        } catch (e) {
          alert("Lß╗ùi save: " + e.message);
        }
      };

      const getNode = (root, path) => {
        let cur = root;
        for (const k of path) cur = cur[k];
        return cur;
      };

      const updateNode = (path, val) => {
        const newData = { ...data };
        let cur = newData;
        for (let i = 0; i < path.length - 1; i++) cur = cur[path[i]];
        if (val === undefined) delete cur[path[path.length - 1]];
        else cur[path[path.length - 1]] = val;
        setData(newData);
      };

      const addNode = (path, isLeaf) => {
        const name = prompt(
          isLeaf ? "Nhß║¡p t├¬n Kß║┐t quß║ú (FDF/HTML):" : "Nhß║¡p t├¬n Nh├ính con:"
        );
        if (!name) return;
        const parent = path.length ? getNode(data, path) : data;
        if (parent[name]) {
          alert("T├¬n n├áy ─æ├ú tß╗ôn tß║íi!");
          return;
        }
        const newNode = isLeaf
          ? {
            displayName: name,
            pdf: "",
            note: "",
            xmttib: "",
            xmttecom: "",
            type: "leaf",
          }
          : {};
        const newData = JSON.parse(JSON.stringify(data));
        let cur = newData;
        path.forEach((p) => (cur = cur[p]));
        cur[name] = newNode;
        setData(newData);
        setExpandedNodes((prev) => new Set([...prev, path.join(".")]));
      };

      // --- RENAME NODE FUNCTION (CORE FIX) ---
      const renameNode = (path) => {
        const parentPath = path.slice(0, -1);
        const oldName = path[path.length - 1];

        const newName = prompt(`─Éß╗òi t├¬n "${oldName}" th├ánh:`, oldName);
        if (!newName || newName === oldName) return;

        const parentNode =
          parentPath.length === 0 ? data : getNode(data, parentPath);
        if (parentNode[newName]) {
          alert("T├¬n n├áy ─æ├ú tß╗ôn tß║íi!");
          return;
        }

        const keys = Object.keys(parentNode);
        const newParentNode = {};
        keys.forEach((k) => {
          if (k === oldName) {
            newParentNode[newName] = parentNode[oldName];
          } else {
            newParentNode[k] = parentNode[k];
          }
        });

        if (parentPath.length === 0) {
          setData(newParentNode);
        } else {
          updateNode(parentPath, newParentNode);
        }

        // Re-expand path
        const oldPathStr = path.join(".");
        const newPath = [...parentPath, newName];
        const newPathStr = newPath.join(".");
        if (expandedNodes.has(oldPathStr)) {
          const next = new Set(expandedNodes);
          next.delete(oldPathStr);
          next.add(newPathStr);
          setExpandedNodes(next);
        }
      };

      const moveNode = (path, direction) => {
        const parentPath = path.slice(0, -1);
        const nodeKey = path[path.length - 1];
        const parentNode =
          parentPath.length === 0 ? data : getNode(data, parentPath);
        const keys = Object.keys(parentNode);
        const index = keys.indexOf(nodeKey);

        if (index === -1) return;
        if (direction === "up" && index === 0) return;
        if (direction === "down" && index === keys.length - 1) return;

        const newKeys = [...keys];
        const swapIndex = direction === "up" ? index - 1 : index + 1;
        [newKeys[index], newKeys[swapIndex]] = [
          newKeys[swapIndex],
          newKeys[index],
        ];

        const newParentNode = {};
        newKeys.forEach((k) => {
          newParentNode[k] = parentNode[k];
        });

        if (parentPath.length === 0) {
          setData(newParentNode);
        } else {
          updateNode(parentPath, newParentNode);
        }
      };

      const isLeafNode = (node) => {
        if (!node || typeof node !== "object") return false;
        if (node.type === "leaf") return true;
        if (
          "pdf" in node ||
          "xmtt" in node ||
          "xmttib" in node ||
          "note" in node ||
          "displayName" in node
        )
          return true;
        return false;
      };

      const renderTree = (node, path = []) => {
        const isLeaf = isLeafNode(node);
        const pathStr = path.join(".");
        const isExpanded = expandedNodes.has(pathStr);
        const currentKey = path[path.length - 1];

        if (isLeaf) {
          return (
            <div
              key={pathStr}
              className="ms-4 mt-2 mb-2 p-3 bg-white border border-success-subtle rounded shadow-sm position-relative"
            >
              <div className="d-flex justify-content-between align-items-start">
                <div>
                  <div className="fw-bold text-success d-flex align-items-center gap-2">
                    <span className="bg-success-subtle small px-2 py-1 rounded">
                      Kß║┐t quß║ú
                    </span>
                    {currentKey}
                  </div>
                  <div className="small mt-1 text-body-secondary">
                    {node.displayName && <div>≡ƒÅ╖∩╕Å {node.displayName}</div>}
                    {node.pdf && <div>≡ƒôä {node.pdf}</div>}
                  </div>
                  <HtmlDisplay content={node.note} />
                </div>
                <div className="d-flex align-items-center gap-1">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      moveNode(path, "up");
                    }}
                    className="btn btn-sm btn-link text-secondary p-1"
                    title="L├¬n"
                  >
                    <BtnIcon name="ArrowUp" size={14} />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      moveNode(path, "down");
                    }}
                    className="btn btn-sm btn-link text-secondary p-1"
                    title="Xuß╗æng"
                  >
                    <BtnIcon name="ArrowDown" size={14} />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      renameNode(path);
                    }}
                    className="btn btn-sm p-1"
                    style={{ color: '#9333ea' }}
                    title="Sß╗¡a t├¬n Kß║┐t quß║ú"
                  >
                    <BtnIcon name="Edit2" size={14} />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      setEditingNode({ path, node });
                    }}
                    className="btn btn-sm btn-link text-primary p-1"
                  >
                    <BtnIcon name="Edit2" size={14} />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      if (confirm("X├│a kß║┐t quß║ú n├áy?"))
                        updateNode(path, undefined);
                    }}
                    className="btn btn-sm btn-link text-danger p-1"
                  >
                    <BtnIcon name="Trash2" size={14} />
                  </button>
                </div>
              </div>
            </div>
          );
        }

        const keys = Object.keys(node || {});
        return (
          <div
            key={pathStr}
            className={`mt-2 ${path.length ? "ms-4 border-start border-2 ps-2" : ""
              }`}
          >
            <div className="d-flex align-items-center gap-2 py-1 bg-light bg-opacity-50 rounded pe-2">
              <button
                onClick={() => {
                  const next = new Set(expandedNodes);
                  if (next.has(pathStr)) next.delete(pathStr);
                  else next.add(pathStr);
                  setExpandedNodes(next);
                }}
                className="btn btn-sm btn-link text-secondary p-1"
              >
                {isExpanded ? (
                  <BtnIcon name="ChevronDown" />
                ) : (
                  <BtnIcon name="ChevronRight" />
                )}
              </button>
              <span className="fw-semibold text-dark flex-fill text-truncate">
                {currentKey || "Root"}{" "}
                <span className="small text-secondary fw-normal ms-2">
                  ({keys.length})
                </span>
              </span>

              <div className="d-flex align-items-center gap-1">
                {path.length > 0 && (
                  <>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        moveNode(path, "up");
                      }}
                      className="btn btn-sm btn-link text-secondary p-1"
                      title="L├¬n"
                    >
                      <BtnIcon name="ArrowUp" size={14} />
                    </button>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        moveNode(path, "down");
                      }}
                      className="btn btn-sm btn-link text-secondary p-1 me-2"
                      title="Xuß╗æng"
                    >
                      <BtnIcon name="ArrowDown" size={14} />
                    </button>
                    {/* --- N├ÜT ─Éß╗öI T├èN NH├ôM (T├ìM) --- */}
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        renameNode(path);
                      }}
                      className="btn btn-sm p-1 me-2"
                      style={{ color: '#9333ea' }}
                      title="Sß╗¡a t├¬n ─Éiß╗üu kiß╗çn"
                    >
                      <BtnIcon name="Edit2" size={14} />
                    </button>
                  </>
                )}
                <button
                  onClick={() => addNode(path, true)}
                  className="btn btn-sm btn-success p-1 d-flex align-items-center gap-1"
                  title="Th├¬m Kß║┐t quß║ú (PDF/HTML)"
                >
                  <BtnIcon name="Plus" size={14} /> Th├¬m PDF/HTML
                </button>
                <button
                  onClick={() => addNode(path, false)}
                  className="btn btn-sm btn-primary p-1 d-flex align-items-center gap-1"
                  title="Th├¬m Nh├ính con"
                >
                  <BtnIcon name="Plus" size={14} /> Th├¬m nh├ính con
                </button>

                {path.length > 0 && (
                  <button
                    onClick={() => {
                      if (confirm("X├│a nh├ính n├áy?"))
                        updateNode(path, undefined);
                    }}
                    className="btn btn-sm btn-danger p-1 ms-1"
                    title="X├│a Nh├ính"
                  >
                    <BtnIcon name="Trash2" size={14} />
                  </button>
                )}
              </div>
            </div>
            {isExpanded && (
              <div className="animate-fade-in">
                {keys.map((k) => renderTree(node[k], [...path, k]))}
                {keys.length === 0 && (
                  <div className="ms-5 text-secondary fst-italic small py-2">
                    Nh├ính trß╗æng.
                  </div>
                )}
              </div>
            )}
          </div>
        );
      };

      const ConstantsManager = () => {
        const [activeGroup, setActiveGroup] = useState(
          Object.keys(groupedConstants)[0] || "Ch╞░a ph├ón loß║íi"
        );
        const [tempGroups, setTempGroups] = useState(groupedConstants);
        const updateMainState = (newGroups) => {
          setTempGroups(newGroups);
          setGroupedConstants(newGroups);
        };
        const addGroup = () => {
          const name = prompt("T├¬n nh├│m mß╗¢i:");
          if (!name) return;
          if (tempGroups[name]) {
            alert("Nh├│m ─æ├ú tß╗ôn tß║íi");
            return;
          }
          updateMainState({ ...tempGroups, [name]: {} });
          setActiveGroup(name);
        };

        // ─Éß╗òi t├¬n Nh├│m Biß║┐n
        const renameGroup = (targetGroup) => {
          const groupToRename = targetGroup || activeGroup;
          const newName = prompt(
            `─Éß╗òi t├¬n nh├│m "${groupToRename}" th├ánh:`,
            groupToRename
          );
          if (!newName || newName === groupToRename) return;
          if (tempGroups[newName]) {
            alert("T├¬n nh├│m ─æ├ú tß╗ôn tß║íi!");
            return;
          }
          const newGroups = {};
          Object.keys(tempGroups).forEach((key) => {
            if (key === groupToRename)
              newGroups[newName] = tempGroups[groupToRename];
            else newGroups[key] = tempGroups[key];
          });
          updateMainState(newGroups);
          if (activeGroup === groupToRename) setActiveGroup(newName);
        };

        const deleteGroup = () => {
          if (Object.keys(tempGroups).length <= 1) return;
          if (!confirm(`X├│a group ${activeGroup}?`)) return;
          const n = { ...tempGroups };
          delete n[activeGroup];
          updateMainState(n);
          setActiveGroup(Object.keys(n)[0]);
        };
        const addVar = (e) => {
          e.preventDefault();
          const k = e.target.key.value.trim();
          const v = e.target.val.value;
          let exists = false;
          Object.values(tempGroups).forEach((g) => {
            if (g[k]) exists = true;
          });
          if (k && v && !exists) {
            const n = { ...tempGroups };
            n[activeGroup][k] = v;
            setTempGroups(n);
            e.target.reset();
          } else if (exists) alert("T├¬n biß║┐n bß╗ï tr├╣ng!");
        };
        const deleteVar = (key) => {
          if (!confirm("X├│a biß║┐n n├áy?")) return;
          const n = { ...tempGroups };
          delete n[activeGroup][key];
          setTempGroups(n);
        };
        const updateVar = (key, newVal) => {
          const n = { ...tempGroups };
          n[activeGroup][key] = newVal;
          setTempGroups(n);
          // Chß╗ë sync vß╗¢i groupedConstants khi ng╞░ß╗¥i d├╣ng thß╗▒c sß╗▒ cß║ºn (kh├┤ng phß║úi mß╗ùi keystroke)
        };

        return (
          <div className="position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center p-4" style={{ backgroundColor: 'rgba(0,0,0,0.5)', zIndex: 1050 }}>
            <div className="bg-white rounded shadow-lg w-100 d-flex flex-column overflow-hidden" style={{ maxWidth: '1200px', height: '85vh' }}>
              <div className="p-3 border-bottom d-flex justify-content-between bg-light">
                <h5 className="fw-bold d-flex align-items-center gap-2 mb-0">
                  <BtnIcon name="FileText" /> Quß║ún l├╜ Biß║┐n
                </h5>
                <button onClick={() => {
                  setGroupedConstants(tempGroups); // L╞░u thay ─æß╗òi tr╞░ß╗¢c khi ─æ├│ng
                  setShowConstModal(false);
                }} className="btn-close"></button>
              </div>
              <div className="d-flex flex-fill overflow-hidden">
                <div className="border-end bg-light d-flex flex-column p-2 gap-2 overflow-auto" style={{ width: '25%' }}>
                  <button
                    onClick={addGroup}
                    className="w-100 btn btn-outline-primary btn-sm border-dashed"
                  >
                    + Nh├│m mß╗¢i
                  </button>
                  {Object.keys(tempGroups).map((g) => (
                    <div
                      key={g}
                      onClick={() => setActiveGroup(g)}
                      className={`p-2 rounded small d-flex justify-content-between align-items-center ${activeGroup === g
                        ? "bg-primary bg-opacity-25 fw-bold text-primary"
                        : "bg-white"
                        }`}
                      style={{ cursor: 'pointer' }}
                    >
                      <span className="text-truncate flex-fill">{g}</span>
                      <div className="d-flex align-items-center gap-1">
                        <span className="badge bg-white text-dark border">
                          {Object.keys(tempGroups[g]).length}
                        </span>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            renameGroup(g);
                          }}
                          className="btn btn-sm btn-link text-secondary p-1"
                          title="─Éß╗òi t├¬n"
                        >
                          <BtnIcon name="Edit2" size={14} />
                        </button>
                      </div>
                    </div>
                  ))}
                  <button
                    onClick={deleteGroup}
                    className="mt-auto btn btn-outline-danger btn-sm"
                  >
                    X├│a Group n├áy
                  </button>
                </div>
                <div className="d-flex flex-column bg-white p-3" style={{ width: '75%' }}>
                  <div className="d-flex justify-content-between align-items-center mb-3 border-bottom pb-2">
                    <h5 className="fw-bold text-primary d-flex align-items-center gap-2 mb-0">
                      <BtnIcon name="Folder" /> {activeGroup}
                    </h5>
                    <button
                      onClick={() => renameGroup(activeGroup)}
                      className="btn btn-sm btn-outline-secondary d-flex align-items-center gap-1"
                    >
                      <BtnIcon name="Edit2" size={14} /> ─Éß╗òi t├¬n nh├│m
                    </button>
                  </div>
                  <div className="flex-fill overflow-auto mb-3">
                    {Object.keys(tempGroups[activeGroup] || {}).length ===
                      0 && (
                        <div className="text-secondary text-center py-5">
                          Trß╗æng
                        </div>
                      )}
                    {Object.entries(tempGroups[activeGroup] || {}).map(
                      ([k, v]) => (
                        <div key={k} className="d-flex gap-2 border-bottom pb-2 mb-2">
                          <input
                            className="form-control form-control-sm font-monospace fw-bold text-primary bg-light"
                            style={{ width: '25%' }}
                            readOnly
                            value={k}
                          />
                          <textarea
                            className="form-control form-control-sm code-input"
                            style={{ width: '70%' }}
                            rows={Math.max(1, v.split("\n").length)}
                            value={v}
                            onChange={(e) => updateVar(k, e.target.value)}
                          />
                          <button
                            onClick={() => deleteVar(k)}
                            className="btn btn-sm btn-link text-danger"
                          >
                            <BtnIcon name="Trash2" />
                          </button>
                        </div>
                      )
                    )}
                  </div>
                  <form
                    onSubmit={addVar}
                    className="d-flex gap-2 pt-3 border-top bg-light p-2 rounded"
                  >
                    <input
                      name="key"
                      placeholder="T├¬n biß║┐n (KEY)..."
                      className="form-control form-control-sm font-monospace"
                      style={{ width: '25%' }}
                      required
                    />
                    <textarea
                      name="val"
                      placeholder="Gi├í trß╗ï (VALUE)..."
                      className="form-control form-control-sm"
                      style={{ width: '65%' }}
                      rows={1}
                      required
                    />
                    <button className="btn btn-success fw-bold" style={{ width: '10%' }}>
                      +
                    </button>
                  </form>
                </div>
              </div>
            </div>
          </div>
        );
      };

      return (
        <div className="min-vh-100 bg-light p-4">
          <div className="container-fluid bg-white rounded shadow border overflow-hidden" style={{ maxWidth: '1400px' }}>
            <div className="bg-dark text-white p-3 d-flex align-items-center justify-content-between">
              <h1 className="h4 fw-bold d-flex align-items-center gap-2 mb-0">
                ΓÜí Flowchart Editor (v5.0 Final)
              </h1>
              <div className="d-flex gap-2">
                <label className="btn btn-secondary btn-sm d-flex align-items-center gap-2">
                  <BtnIcon name="Upload" size={16} /> Tß║úi file
                  <input
                    type="file"
                    accept=".js"
                    onChange={handleFileUpload}
                    className="d-none"
                  />
                </label>
                <button
                  onClick={() => setShowConstModal(true)}
                  className="btn btn-warning btn-sm d-flex align-items-center gap-2"
                >
                  <BtnIcon name="FileText" size={16} /> Biß║┐n
                </button>
                <button
                  onClick={handleDownload}
                  className="btn btn-success btn-sm d-flex align-items-center gap-2"
                >
                  <BtnIcon name="Download" size={16} /> L╞░u file
                </button>
              </div>
            </div>
            <div className="p-4">
              {Object.keys(data).length === 0 ? (
                <div className="text-center py-5 text-secondary border border-2 border-dashed rounded">
                  Ch╞░a c├│ dß╗» liß╗çu.
                  <br />
                  <button
                    onClick={() => addNode([], false)}
                    className="btn btn-primary mt-3"
                  >
                    Tß║ío nh├│m gß╗æc mß╗¢i
                  </button>
                </div>
              ) : (
                <div>
                  {Object.keys(data).map((key) =>
                    renderTree(data[key], [key])
                  )}
                </div>
              )}
            </div>
          </div>
          {editingNode && (
            <div className="position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center p-4" style={{ backgroundColor: 'rgba(0,0,0,0.5)', zIndex: 1050 }}>
              <div className="bg-white rounded shadow-lg w-100 d-flex flex-column" style={{ maxWidth: '900px', maxHeight: '90vh' }}>
                <div className="p-3 border-bottom d-flex justify-content-between align-items-center bg-light rounded-top">
                  <h5 className="fw-bold mb-0">
                    Chß╗ënh sß╗¡a: {editingNode.path.join(" > ")}
                  </h5>
                  <button
                    onClick={() => setEditingNode(null)}
                    className="btn-close"
                  ></button>
                </div>
                <div className="p-4 overflow-auto">
                  <div className="row g-3 mb-3">
                    <div className="col-md-6">
                      <label className="form-label small fw-medium">
                        T├¬n hiß╗ân thß╗ï (Display Name)
                      </label>
                      <input
                        className="form-control"
                        value={editingNode.node.displayName || ""}
                        onChange={(e) =>
                          setEditingNode({
                            ...editingNode,
                            node: {
                              ...editingNode.node,
                              displayName: e.target.value,
                            },
                          })
                        }
                      />
                    </div>
                    <div className="col-md-6">
                      <label className="form-label small fw-medium">
                        File PDF
                      </label>
                      <input
                        className="form-control"
                        value={editingNode.node.pdf || ""}
                        onChange={(e) =>
                          setEditingNode({
                            ...editingNode,
                            node: {
                              ...editingNode.node,
                              pdf: e.target.value,
                            },
                          })
                        }
                      />
                    </div>
                  </div>
                  {["note", "xmttib", "xmttecom", "alert"].map((f) => (
                    <div key={f} className="mb-3">
                      <label className="form-label small fw-medium text-uppercase text-secondary">
                        {f} (Hß╗ù trß╗ú HTML)
                      </label>
                      <textarea
                        className="form-control code-input bg-light"
                        rows={3}
                        value={
                          Array.isArray(editingNode.node[f])
                            ? editingNode.node[f].join("\n")
                            : editingNode.node[f] || ""
                        }
                        onChange={(e) =>
                          setEditingNode({
                            ...editingNode,
                            node: {
                              ...editingNode.node,
                              [f]: e.target.value,
                            },
                          })
                        }
                      />
                    </div>
                  ))}
                </div>
                <div className="p-3 border-top bg-light rounded-bottom d-flex justify-content-between">
                  <button
                    onClick={() => {
                      if (confirm("X├│a kß║┐t quß║ú n├áy?")) {
                        updateNode(editingNode.path, undefined);
                        setEditingNode(null);
                      }
                    }}
                    className="btn btn-outline-danger d-flex gap-2 align-items-center"
                  >
                    <BtnIcon name="Trash2" /> X├│a
                  </button>
                  <button
                    onClick={() => {
                      updateNode(editingNode.path, editingNode.node);
                      setEditingNode(null);
                    }}
                    className="btn btn-primary d-flex gap-2 align-items-center"
                  >
                    <BtnIcon name="Save" /> L╞░u
                  </button>
                </div>
              </div>
            </div>
          )}
          {showConstModal && <ConstantsManager />}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<FlowchartEditor />);
  </script>
</body>

</html>
